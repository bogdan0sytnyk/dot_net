<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, C">

<title>Основы программирования. Лабораторные работы </title>
<!--                                                                   -->
<!-- (C) Owner: Alexander S. Derevjanko -->
<!-- (C) ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l07.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l09.html>Вперед</a></td></tr>
</table>
</p>
<hr>
<h2 align="center">Лабораторная работа ╧8</h2>
<h2 align="center"> Работа с массивами</h2>
<h3 align=center> 1. Цель работы </h3>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Целью лабораторной работы является получение 
  практических навыков в работе с массивами в языке C.</p>
<h3 align=center>2. Темы для предварительной проработки</h3>
<ul>
  <li>Операторы цикла языка C. Вложенные циклы.</li>
  <li>Условный оператор языка C.</li>
  <li>Массивы. </li>
</ul>
<h3 align=center>3. Задание </h3>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Объявить массив целых чисел и заполнить его случайными 
  значениями. Размер массива и диапазон значений его элементов заданы в Вашем 
  варианте индивидуального задания. В индивидуальных заданиях указано также, 
  какую обработку массива следует произвести.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для всех вариантов задания следует иметь в виду 
  следующее:</p>
<ul>
  <li> 0 считается положительным числом, если в задании не оговорен какой-то другой 
    его статус;</li>
  <li> когда речь идет о какой-то последовательности чисел, имеется в виду последовательность 
    с длиной, большей 1;</li>
  <li> в тех случаях, когда задание требует выполнения каких-то вычислений, разрешается 
    выполнять их с той точностью, которую обеспечивают операции целочисленной арифметики.</li>
</ul>
<h3 align=center>4. Варианты индивидуальных заданий</h3>
<p><table align=center>
<tr><td>&nbsp;<a href=v08_01.html>1</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_02.html>2</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_03.html>3</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_04.html>4</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_05.html>5</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_06.html>6</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_07.html>7</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_08.html>8</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_09.html>9</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_10.html>10</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v08_11.html>11</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_12.html>12</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_13.html>13</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_14.html>14</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_15.html>15</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_16.html>16</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_17.html>17</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_18.html>18</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_19.html>19</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_20.html>20</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v08_21.html>21</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_22.html>22</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_23.html>23</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_24.html>24</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_25.html>25</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_26.html>26</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_27.html>27</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_28.html>28</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_29.html>29</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_30.html>30</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table>
</p>
<h3 align=center>5. Пример решения задачи (вариант 30)</h3>
<h4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1. Разработка алгоритма.</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Схема алгоритма показана на рисунке ниже.</p>
<p align="center"><img src="lab08_1.gif" width="368" height="539" border="0"></p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В первой фазе выполнения программы 
  нам необходимо будет сформировать массив случайных чисел. Перед тем как мы будем 
  обращаться к датчику случайных чисел,  необходимо его проинициализировать (блок 
  2). Далее организуем цикл со счетчиком (блок 3), в каждой итерации которого 
  генерируется следующее случайное число и записывается в следующий элемент массива 
  (блок 4). После окончания цикла заполнения массива выводим массив на экран (блок 
  5). </p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Нам необходимо будет вычислять среднее 
  значение последовательности, следовательно - подсчитывать количество элементов 
  в ней. Для этого мы вводим переменную <b><i>nn</i></b> - счетчик элементов, нулевое значение 
  этой переменной будет показывать, что у нас нет последовательности для обработки. 
  В начале обработки мы устанавливаем <b><i>nn=0</i></b> (блок 6).</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее организуем цикл со счетчиком 
  (блок 7), в котором перебираем элементы массива. Для каждого элемента в первую 
  очередь проверяется его знак (блок 8). Если это отрицательный элемент, то это 
  может быть первый или не первый элемент последовательности. Это можно определить, 
  проверяя значение переменной <b><i>nn</i></b>: если она 0 - это первый элемент (блок 9). Для 
  первого элемента мы запоминаем в переменной <b><i>ib</i></b> индекс начала последовательности, 
  устанавливаем счетчик элементов <b><i>nn</i></b> в 1, а в переменную <b><i>av</i></b> записываем значение 
  этого элемента (блок 10). Для не первого элемента мы увеличиваем счетчик на 
  1, а значение элемента суммируем со занчением переменной <b><i>av</i></b> (блок 11). Таким образом, переменная 
  <b><i>av</i></b> у нас играет роль накопителя суммы элементов последовательности. </p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если же очередной элемент последовательности 
  положительный, то возникает вопрос - не является ли этот элемент первым положительным 
  элементом после отрицательной последовательности? Это можно проверить по
  счетчику <b><i>nn</i></b>. Если элемент первый, то значение <b><i>nn</i></b> должно быть больше 0 (блок 12). Если 
  нет, то нам необходимо обработать ту отрицательную последовательность, которая 
  только что закончилась. Для обработки мы в первую очередь получаем среднее значение 
  (блок 13). Потом организуем цикл (блок 14) со счетчиком <b><i>j</i></b>, который изменяется 
  от <b><i>ib</i></b> (индекс начала отрицательной последовательности, который мы сохранили 
  раньше) до <b><i>i-1</i></b> (<b><i>i</i></b> - это индекс первого положительного элемента после отрицательной 
 - это индекс первого положительного элемента после отрицательной 
  последовательности, следовательно <b><i>i-1</i></b> - индекс последнего элемента отрицательной 
  последовательности). В каждой итерации этого цикла мы сравниваем <b><i>j</i></b>-й элемент 
  массива со средним значением <b><i>av</i></b> (блок 15). Если значение элемента меньше среднего 
  (т.е. больше по абсолютному значению), то среднее значение записывается в <b><i>j</i></b>-й 
  элемент (блок 16), если же нет - ничего не происходит. По выходу из цикла мы 
  устанавливаем счетчик <b><i>nn</i></b> в 0 (блок 17), как признак того, что у нас нет необработанной 
  последовательности. Для не первого положительного элемента нет необходимости 
  что-либо делать.</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После выхода из того цикла, который начался 
  в блоке 7, необходимо проверить, не осталась ли у нас необработанная последовательность 
  и, если да, обработать ее. На схеме алгоритма мы показали это одним блоком 18, 
  действия, которые выполняются в этом блоке тождественны действиям, которые 
  детально показаны в блоках 12 - 17.</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По окончанию обработки мы выводим 
  массив-результат (блок 19) и заканчиваем программу.</p>
<h4 align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2. Определение переменных программы</h4>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для реализации алгоритма нам будут 
  необходимы следующие переменные.</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Массив целых чисел, который будет 
  обрабатываться:</p>
<pre>       int Ar[100]; </pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Массив должен располагаться в статической памяти.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Индексы элементов массива для внешнего (блоки 
  3 - 17) и внутреннего (блоки 14 - 16) циклов:</p>
<pre>        int i, j; </pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Переменные, в которых будут храниться параметры 
  очередной последовательности: сумма элементов, а потом среднее значение - <i><b>av</b></i>, 
  количество элементов в последовательности - <i><b>nn</b></i>, индекс начала 
  последовательности - <i><b>ib</b></i>:</p>
<pre>    int av; 
    int nn; 
    int ib; 
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Отметим, что для большинства данных, которые 
  представляются переменными программы, достаточно было бы и типа <i><b>short</b></i> 
  или <i><b>char</b></i>, т.к. их значения укладываются в диапазон: -128 - 
  128. Мы выбираем тип <i><b>int </b></i>согласно с общим стилем программирования 
  на языке C. Отдельного рассмотрения требует переменная <i><b>av</b></i>, т.к. 
  в ней накапливается сумма, а значит, ее значение может значительно превысить значения 
  остальных переменных. Но в наихудшем случае (когда все элементы массива будут 
  иметь максимальные значения) ее значение не превысит 100*50=5000, следовательно 
  типа <i><b>int</b></i> достаточно и для нее.</p>
<h4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3. Разработка текста программы</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В начале текста программы включаем в него файлы, содержащие описания тех функций, 
  к каким мы будем обращаться:</p>
<pre>    #include &lt;stdio.h&gt;
    #include &lt;time.h&gt;
    #include &lt;stdlib.h&gt;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В файле <i><b>stdio.h</b></i> описания 
  функций стандартного ввода-вывода, в файле <i><b>stdlib.h</b></i> - функции 
  генерации случайных чисел. В описании функции <i><b>randomize()</b></i> мы нашли 
  примечание, что она является макросом, который обращается к функции <i><b>time()</b></i>, 
  следовательно, перед файлом <i><b>stdlib.h</b></i> в программу должен быть включен 
  файл <i><b>time.h</b></i>.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Мы обусловили, что массив должен размещаться 
  в статической памяти. Если мы объявим массив до открытия тела главной функции, 
  то он будет размещен именно в статической памяти. Поэтому далее у нас идет объявление 
  массива.</p>
<pre>    int Ar[100]; </pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее ставим заголовок главной функции <i><b>main</b></i> 
  и открываем ее тело:</p>
<pre>    int main(void){ 
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Главная функция начинается с объявления остальных 
  переменных программы см. п.5.2. </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Кодовая часть программы начинается с обращения 
  к функции инициализации датчика случайных чисел (блок 2):</p>
<pre>    randomize(100);</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее организуем простой цикл со счетчиком (блок 
  3), в каждой итерации которого в следующий элемент массива записывается случайное 
  число (блок 4). Обращение к функции <i><b>rand(</b></i><b><i>)</i></b> возвращает 
  нам число в пределах 0 - 100; вычитая из него 50, мы приводим его к диапазону 
  -50 - +50.</p>
<pre>    for (i=0; i&lt;100; Ar[i++]=random(101)-50 );</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Заполненный таким образом массив в цикле выводим 
  на экран (блок 5). Формат вывода каждого элемента - <i><b>%3d</b></i> - обеспечивает 
  отображение числа из двух цифр со знаком. Между числами задаеv еще два пробела, 
  таким образом, каждый элемент занимает 5 позиций, а в одной строке экрана разместится 
  целое число (16) элементов, что обеспечит удобное представление массива.</p>
<pre>    printf("Начальный массив:\n");
    for (i=0; i&lt;100; printf("%3d  ",Ar[i++]));
    putchar('\n');
    putchar('\n'); </pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее идет заголовок цикла перебора массива (блок 
  7), в котором мы также присваиваем начальное значение счетчику <b><i>nn</i></b> (блок 6):</p>
<pre>    for (nn=i=0; i&lt;100; i++) { </pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Все тело цикла состоит из одного условного оператора. 
  В этом операторе проверяем (блок 8) знак <b><i>i</i></b>-го элемента массива:</p>
<pre>    if (Ar[i]&lt;0) </pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если это условие - истина, то проверяем, не равен 
  ли 0 счетчик элементов последовательности <b><i>nn</i></b> (блок 9):</p>
<pre>    if (!nn) </pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При выполнении этого условия выполняется ряд 
  действий (блок 10), которые мы берем в операторные скобки:</p>
<pre>{ ib=i; av=Ar[i]; nn=1; }</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если же условие ложно, то выполняется сложный 
  оператор (блок 11):</p>
<pre>   else { av+=Ar[i]; nn++; }</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если же элемент положительный, то выполняется 
  часть <i><b>else</b></i> первого условного оператора, в которой анализируется 
  <b><i>nn</i></b> - нет ли у нас необработанной отрицательной последовательности (блок 12):</p>
<pre>    else if (nn) { </pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если есть необработанная последовательность, 
  выполняем усреднение значения <i><b>av</b></i> (блок 13):</p>
<pre>    av/=nn; </pre>
<p>и организуем цикл с параметром j, который изменяется от<i><b> ib</b></i> до<i><b> 
  i</b></i>-1(блок 14): </p>
<pre>    for (j=ib; j&lt;i; j++) </pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;В каждой итерации этого цикла <i><b>j</b></i>-й элемент 
  массива сравнивается с средним значением (блок 15) и, если он больше, заменяется 
  на среднее значение (блок 16). Это реализуется одним условным оператором:</p>
<pre>    if (Ar[j]&lt;av) Ar[j]=av;</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При выходе из цикла записываем 0 в счетчик nn 
  (блок 17):</p>
<pre>    nn=0;</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На этом заканчивается и внешний цикл.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Несколько операторов, которые следуют после выхода 
  из цикла (блок 18), обеспечивают обработку последней последовательности и в 
  основном являются копией тех операторов, которые реализуют блоки 12 - 17. Разница 
  состоит в том, что тут мы внесли усреднение в начальное действие цикла и убрали 
  присваивание <i><b>nn=0</b></i>, т.к. значение <b><i>nn</i></b> нам больше не понадобится.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Операторы вывода массива-результата - копия вывода 
  начального массива.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Полный текст программы приведен ниже.</p>
<pre>/***************************************************/
/*             Лабораторная работа ╧8              */
/*               Работа с массивами                */
/*           Пример решения. Вариант ╧30.          */
/***************************************************/
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
 int Ar[100];   /* массив, который обрабатывается */

int main(void) {
 int i, j;    /* индексы в массиве */
 int av;      /* среднее значение */
 int nn; /* количество эл-тов в последовательности */ 
 int ib;      /* индекс начала последовательности */

  randomize();  /* инициализация rand */
  /* заполнение массива случайными числами */
  for (i=0; i&lt;100; Ar[i++]=random(101)-50 );
  /* вывод начального массива */
  printf("Начальный массив:\n");
  for (i=0; i&lt;100; printf("%3d  ",Ar[i++]));
  putchar('\n');
  putchar('\n');

  for (nn=i=0; i&lt;100; i++) { /* перебор массива */
    if (Ar[i]&lt;0) 
      /* обработка отрицательного элемента */
      if (!nn) {
        /* начало последовательности */
        /* запомнить индекс начала,
           начальное значение накопителя суммы 
           и счетчика элементов */
        ib=i; av=Ar[i]; nn=1;
        }
      else {
        /* накопление суммы, 
           подсчет количества */
        av+=Ar[i]; nn++;
        }
    /* конец обработки отрицательного элемента */
    else /* обработка положительного элемента */
      if (nn) { 
        /* если есть необработанная 
           отрицательная последовательность */
        av/=nn;   /* усреднение */
        /* перебор всей последовательности 
           с ограничением */
        for (j=ib; j&lt;i; j++)
          if (Ar[j]&gt;av) Ar[j]=av;
            nn=0; /* последовательность обработана */
        } /* конец если есть необработанная... */ 
    }  /* конец перебор массива */
  if (nn) /* если не обработана последняя
             отрицательная последовательность */
    for (av/=nn, j=ib; j&lt;i; j++)
      if (Ar[j]&gt;av) Ar[j]=av;
  /* вывод результатов */
  printf("Массив-результат:\n");
  for (i=0; i&lt;100; printf("%3d  ",Ar[i++]));
  putchar('\n');

  return 0;
}</pre>
<h4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4. Отладка программы</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Отладка программы включает в себя в первую очередь 
  проверку результатов, которые выдает программа. Размер массива и значения элементов 
  таковы, что не составит труда проверить преобразования нескольких последовательностей, 
  выполняя вычисления вручную или при помощи калькулятора. </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если же обнаруживаются ошибки в результатах, 
  то можно использовать пошаговый метод отладки, при этом следует проверять работу 
  алгоритма отдельно по ветвям: 7 - 8 - 9 - 10; 7 - 8 - 9 - 11; 7 - 8 - 12 - 13 
  - 14 - 15 - 16 - 17. При пошаговой отладке следует отслеживать в первую очередь 
  значения тех переменных, которые отвечают за преобразование - <i><b>ib</b></i>, <i><b>nn</b></i>, 
  <i><b>av</b></i>.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Отдельно следует проверять работу программы для 
  случаев, когда массив начинается отрицательной последовательностью и когда массив 
  заканчивается отрицательной последовательностью.</p>
<h4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.5. Результаты работы программы</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Образец результатов программы приведен ниже</p>
<pre>Начальный массив:
 22   15   45  -15  -19   19  -38   34  -39   37   -3  -25   33  -11  -27  -45
 47   29    5  -14   17  -40  -34   -8   46  -29   40    0   17    9   38   17
 42  -47  -27    9    1   30  -33   -4  -50   27  -10    1   41   24   -7  -41
 35   35   41   12   37  -49   16   29   49  -11  -15   35  -39   43    3   19
-20   21  -45   -3   13  -12    3  -13   12  -11   34   -5  -14  -35  -13  -50
 -2   48   47   -4   45   46  -13  -29   45  -12  -45   -2   21  -33  -42   -2
 13   27  -24  -42  

Массив-результат:
 22   15   45  -15  -17   19  -38   34  -39   37   -3  -14   33  -11  -27  -27
 47   29    5  -14   17  -27  -27   -8   46  -29   40    0   17    9   38   17
 42  -37  -27    9    1   30  -29   -4  -29   27  -10    1   41   24   -7  -24
 35   35   41   12   37  -49   16   29   49  -11  -13   35  -39   43    3   19
-20   21  -24   -3   13  -12    3  -13   12  -11   34   -5  -14  -19  -13  -19
 -2   48   47   -4   45   46  -13  -21   45  -12  -19   -2   21  -25  -25   -2
 13   27  -24  -42  </pre>
<h4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.6. Выводы </h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При выполнении лабораторной работы рассмотрены 
  вопросы</p>
<ul>
  <li> работы с массивами;</li>
  <li> написания и отладки циклических программ, включая вложенные циклы.</li>
</ul>
<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l07.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l09.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>
