<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, C">

<title>Основы программирования. Лабораторные работы </title>
<!--                                                                   -->
<!-- (C) Owner: Alexander S. Derevjanko -->
<!-- (C) ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>

<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l15.html>Назад</a></td><td><a href=index.html>Оглавление</a></td>
</tr>
</table>
</p>
<hr>
  <h2 align=center>Лабораторная работа ╧16<br>
  Прямой файловый ввод-вывод </h2>
  <h3 align=center>1. Цель работы</h3>
  <p>Целью лабораторной работы является получение практических навыков 
    в работе с функциями прямого файлового ввода-вывода. </p>
  <h3 align="center">2. Темы для предварительной проработки</h3>
<ul>
  <li>Функции пользователя</li>
  <li>Создание программных проектов</li>
  <li>Прямой файловый ввод-вывод </li>
</ul>
  <h3 align="center">3. Задания для выполнения</h3>
  <p>Выполнить задание лабораторной работы ╧14 с условием, 
    что данные, которые обрабатываются программой, находятся в файле, а в оперативной 
    памяти одновременно расположен только одна запись файла.</p>
  <h3 align="center">4. Варианты индивидуальных заданий</h3>
<p><table align=center>
<tr><td>&nbsp;<a href=v02_01.html>1</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_02.html>2</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_03.html>3</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_04.html>4</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_05.html>5</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_06.html>6</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_07.html>7</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_08.html>8</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_09.html>9</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_10.html>10</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v02_11.html>11</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_12.html>12</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_13.html>13</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_14.html>14</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_15.html>15</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_16.html>16</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_17.html>17</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_18.html>18</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_19.html>19</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_20.html>20</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v02_21.html>21</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_22.html>22</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_23.html>23</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_24.html>24</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_25.html>25</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_26.html>26</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_27.html>27</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_28.html>28</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_29.html>29</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_30.html>30</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table>
</p>
  <h3 align="center">5. Пример решения задачи (вариант 30)</h3>
  <p>Решение представляется с ссылками на работы ╧╧
  <a href=l02.html>2</a>, <a href=l10.html>10</a>, <a href=l14.html>14</a>.</p>
  <h4>5.1. Определение основных переменных программы</h4>
  <h4>5.2. Определение стректуры программы</h4>
  <p>Как и в работе ╧10, используем ранее разработанную структуру:
  <pre>
  struct mon { . . . }; 
  </pre>
  <p>В этой работе она будет представлять запись файла на внешней 
    памяти. Файл работы ╧14 <b><i>L14.H</b></i> мы можем перенести в этот проект без 
    изменений.</p>
  <p>В данной работе мы предлагаем немного другую структуру работы 
    модулей программы с данными. Если в работе ╧14 масив, который мы обрабатывали, 
    был глобальным, т.е. доступ к нему можно было обеспечить из любых модулей 
    программы, то здесь мы используем, так называемый, подход "спрятанной базы 
    данных" - сделаем файл доступным только из одного модуля, а все остальные модули 
    будут работать с данными файла через функции этого модуля. Нельзя сказать, 
    что какой-то подход абсолютно лучший, а какой-то - худший. Можно было бы 
    решить задачу работы ╧14 со "спрятанной базой данных", или текущую задачу - 
    с глобальной файловой переменной.</p>

  <h4>5.3. Разработка програмных модулей</h4>

  <h4>5.3.1. Структура программы</h4>
  <p>Согласно условию, отдельный модуль должна составлять главная 
    функция. Еще один модуль - функции, которые обеспечивают работу с файлом. 
    Эти функции заменяют функции модуля <b><i>L14-1.C</i></b> из работы ╧14. 
    Наконец, пересмотрев проект работы ╧14, мы приходим к выводу, что все функции, которые 
    определены в файле <b><i>L14-2.C</i></b>, нам пригодятся и в данном проекте, следовательно 
    файлы <b><i>L14-2.C</i></b> и <b><i>L14-2.H</i></b> переносятся в данный проэкт без изменений.</p>

  <h4>5.3.2. Модуль L16.C</h4>
  <p>В этом модуле определяется функция <b><i>main()</i></b>. Ее алгоритм и текст 
    в основном совпадают с алгоритмом и текстом главной функции работы ╧14. 
    отмечаем только некоторые расхождения.</p>
  <p>Имя файла данных в этой работе передается функции  <b><i>main()</i></b> как 
    параметр, значит функция имеет параметры и начинается с проверки параметра 
    (как в работе ╧15). </p>
  <p>Файл данных следует открыть в начале работы программы и закрыть 
    в конце - это выполняется обращением к функциям  <b><i>initf()</i></b> и  <b><i>commit()</i></b> соответственно.</p>
  <p>В функции  <b><i>main()</i></b> есть локальная переменная программы x, в которой 
    хранится одна структура-монастырь. При добавлении новой записи данные вводятся 
    функцией  <b><i>ent_data()</i></b> в эту переменную, а потом передаются функции  <b><i>f_add()</i></b> для 
    записи в файл.</p>

  <h4>5.3.3. Модуль L16-1.C</h4>
  <p>В этом модуле сосредоточены функции, которые имеют доступ к 
    файлу данных. Вне блоков в этом файле объявлена файловая переменная:</p>
  <pre>
static int file;
</pre>

  Эта переменная доступна для всех функций данного файла, но не 
    доступна вне файла.</p>
  <p> В начало текста включаются также библиотечные файлы <b><i>stdio.h</i></b>, 
    <b><i>io.h</i></b> (описание функций прямого файлового ввода-вывода), <b><i>fcntl.h</i></b> и <b><i>sys\stat.h</i></b> 
    (макроконстанты прямого файлового ввода-вывода), <b><i>stdlib.h</i></b> (описание функции 
    <b><i>exit()</i></b>) и собственные файлы <b><i>L14.H</i></b> (описание структуры данных) и <b><i>L14-2.H</i></b> (описания 
    функций пользователя, которые находятся в файле <b><i>L14-2.C</i></b>).</p>

  <p><b>5.3.3.1. Функция initf(). </b><br>
    Функция открывает файл данных. Ее параметр - указатель на символьную 
    строку - имя файла. Функция не возвращает значений.</p>
  <p>Выполнение функции начинается с проверки наличия файла с помощью 
    библиотечной функции <b><i>access()</i></b>. Если <b><i>access()</i></b> возвращает -1, файл не существует, 
    тогда он создается с помощью библиотечной функции <b><i>creat()</i></b>. Созданный файл 
    автоматически открывается на чтение/запись, но по умолчанию при этом устанавливается 
    текстовый режим передачи данных (<b><i>O_TEXT</i></b>). Для установления двоичного режима 
    передачи в системную переменную <b><i>_fmode</i></b> явным образом записывается значения 
    <b><i>O_BINARY</i></b>. </p>
  <p>Если <b><i>access()</i></b> возвращает 0, файл существует, тогда он открывается 
    функцией <b><i>open()</i></b> на чтение/запись в двоичном режиме.</p>
  <p>Значение, которое возвращает функция <b><i>creat()</i></b> или <b><i>open()</i></b>, записывается 
    в общую для модуля переменную <b><i>file</i></b>, через которую обращаются к открытому файлу 
    другие функции модуля.</p>
  <p>И при создании, и при открытии проверяется результат выполнения 
    библиотечной функции и, если он неудовлетворительный (возвращается отрицательное 
    значение), выводится сообщение и программа заканчивается аварийно.</p>

  <p><b>5.3.3.2. Функция commit().</b><br>
  Функция выполняет закрытие файла. Функция не имеет параметров 
    и не возвращает никакого значения. Ее код состоит лишь из вызова библиотечной 
    функции <b><i>close()</i></b>.</p>

  <p><b>5.3.3.3. Функция f_add().</b><br>
  Функция добавляет новую запись в конец файла. Параметр функции 
    - указатель на структуру (<b><i>MON *</i></b>), в которой находятся данные записи. Функция 
    не возвращает значения.</p>
  <p>Функция устанавливает файловый курсор в конец файла <b><i>lseek()</i></b> 
    и записывает в файл данные - <b><i>write()</i></b>. </p>

  <p><b>5.3.3.4. Функция fcheck_number(). </b><br>
Ее параметр - номер записи, возвращает 0 или -1. Функция выполняет 
    то же самое действие, что и функция <b><i>check_number()</i></b> в работе ╧14. Но 
    если там максимальный номер записи сохранялся в переменной программы, тут 
    вон определяется из размера файла. Для этого файловый курсор устанавливается 
    в конец файла, значение, которое при этом возвращает <b><i>lseek()</i></b> - размер файла 
    в байтах. Поделивши его на размер одной записи, получаем количество записей 
    в файле.</p>

  <p><b>5.3.3.5. Функция fshow_1(). </b><br>
  Функция выполняет чтение из файла и вывод на экран данных одной 
    записи с заданным номером. Параметр функции - номер записи, значение не возвращает.</p>
  <p>Функция вычисляет смещение необходимой записи от начала файла 
    в байтах, устанавливает файловый курсор на это место и читает данные в свою 
    локальную переменную х. Для вывода на экран используется функция <b><i>show_1()</i></b>, 
    унаследованная из работы ╧14.</p>

  <p><b>5.3.3.6. Функция fshow_all(). </b><br>
  Функция выполняет чтение из файла и вывод на экран данных всего 
    файла в виде таблици. Параметров не имеет, значение не возвращает.</p>
  <p>Функция устанавливает файловый курсор на начало файла, выводит 
    (<b><i>print_head()</i></b>) заголовок таблици, потом в цикле читает (<b><i>read()</i></b>) следующую 
    запись из файла и выводит его на экран (<b><i>show_row()</i></b>). Когда будет достигнут 
    конец файла, в следующей итерации цикла <b><i>read()</i></b> возвращает 0, что приведет 
    к выходу из цикла.</p>

  <p><b>5.3.3.7. Функция fdel_item(). </b><br>
  Функция извлекает из файла запись с заданным номером. Параметр 
    функции - номер записи, значения не возвращает.</p>
  <p>Алгоритм извлечения - такой же, как и в случае с массивом в 
    работе ╧14, но способы выполнения этого алгоритма на файле совсем другие.</p>
  <p>Сначала вычисляется смещение в файле записи, следующей за заданной 
    и файловый курсор устанавливается на нее. Далее организуется цикл.</p>
  <p>В каждой итерации цикла считывается запись, на которую установлен 
    курсор. Потом курсор смещается назад - на запись, предшествующую считанной 
    и считанные данные записываются туда. Курсор смещается вперед еще на одину 
    запись, эта запись будет читаться в следующей итерации цикла.</p>
  <p>Цикл повторяется, пока не будет достигнут конец файла. Таким 
    образом, все записи, которые размещены за заданной, смещаются на одно место 
    ближе к началу файла.</p>
  <p>По выходе из цикла размер файла ограничмвается записью, предыдущей по отношению 
    к текущей позиции файлового курсора, т.е. уменьшается на одну запись.</p>

  <h4>5.4. Создание программного проекта</h4>
  <p>Техника создания программного проекта - такая же, как и в работе 
   ╧14. В состав проекта включаются модули <b><i>L16</i></b>, <b><i>L16-1</i></b>, <b><i>L14-2</i></b>.</p>

  <h4>5.5. Текст программы</h4>

<pre>
/*******************************************************/
/*               Лабораторная работа ╧16               */
/*              Прямой файловый ввод-вывод             */
/*            Пример выполнения. Вариант ╧30.          */
/*******************************************************/
/*  Файлы L14.H, L14-2.H, L-14-2.C - см.работу ╧14     */
/*******************************************************/

/*******************************************************/
/*               Лабораторная работа ╧16               */
/*                    Файл L16-1.H                     */
/*******************************************************/
/* Описания функций файла L16-1.C */
void initf(char *f);
void commit(void);
void f_add(MON *a);
int fcheck_number(int);
void fshow_1(int);
void fshow_all(void);
void fdel_item(int);

/*******************************************************/
/*               Лабораторная работа ╧16               */
/*                     Файл L16.C                      */
/*******************************************************/
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdlib.h&gt;
#include "l14.h"
#include "l14-2.h"
#include "l16-1.h"

/**** главная функция ****/
int main(int an, char *av[]) {
 MON x;
 int op;    /* операция */
 int num;   /* номер элемента */
 char eoj;  /* признак конця */
  /* проверка параметра */
  if (an&lt;2) {
    printf("Неправильный вызов програмы\n");
    exit(0);
    }
  /* открытие файла */
  initf(av[1]);
  for (eoj=0; !eoj; ) {
    /* вивод меню */
    printf("1 - Добавить элемент\n");
    printf("2 - Удалить элемент\n");
    printf("3 - Показать элемент по номеру\n");
    printf("4 - Показать все\n");
    printf("0 - Виход\n");
    printf("Вводите &gt;");
    /* вибор из меню  */
    scanf("%d",&op);
    switch(op) {
      case 0:
        eoj=1;
        break;
      case 1: /* добавить */
        if (ent_data(&x)&gt;=0)
           f_add(&x);
        break;
      case 2:  /* удалить */
        if (!fcheck_number(num=get_number()))
          fdel_item(num);
        break;
      case 3:  /* показать один */
        if (!fcheck_number(num=get_number()))
          fshow_1(num);
        break;
      case 4: /* показать все */
        fshow_all();
        break;
      default:
        printf("Неправильная операция\n");
        break;
      }
    if (op) {
      printf("Нажмите любую клавишу\n");
      getch();
      }  /* if */
    }  /* for */
  /* закрытие файла */
  commit();
  return 0;
}  /* main */

/*******************************************************/
/*               Лабораторная работа ╧16               */
/*                    Файл L16-1.C                     */
/*******************************************************/
#include &lt;stdio.h&gt;
#include &lt;io.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys\stat.h&gt;
#include &lt;stdlib.h&gt;
#include "l14.h"
#include "l14-2.h"

static int file;  /* файл-таблица */

/**** открытие или создание файла ****/
void initf(char *fname) {
  if (access(fname,0)&lt;0) {
    /* несуществующий файл - создать */
    _fmode=O_BINARY;
    if ((file=creat(fname,S_IREAD|S_IWRITE))&lt;0) {
      printf("Can't create file %s\n",fname);
      exit(0);
      }
    }
  else /* существующий файл - открыть */
    if ((file=open(fname,O_RDWR|O_BINARY))&lt;0) {
      printf("Can't open file %s\n",fname);
      exit(0);
      }
}

/**** закрытие файла ***/
void commit() {
  close(file);
}

/**** добавление в конец файла ****/
void f_add(MON *a) {
  lseek(file,0,SEEK_END);
  write(file,a,SMON);
}

/**** проверка номера записи ****/
int fcheck_number(int n) {
 long nn;
  if (n&lt;1) {
    printf("Минимальный номер : 1\n");
    return -1;
    }
  nn=lseek(file,0,SEEK_END)/SMON;
  if (n&gt;nn) {
    printf("Максимальный номер :%d\n",(int)nn);
    return -1;
    }
  return 0;
}

/**** вивод одной записи ****/
void fshow_1(int n) {
 long t;
 MON x;
  t=n-1; t*=SMON;
  lseek(file,t,SEEK_SET);
  read(file,&x,SMON);
  show_1(&x);
}

/**** вивод всех записей ****/
void fshow_all() {
 MON x;
  lseek(file,0,SEEK_SET);
  print_head();
  while(read(file,&x,SMON))
    show_row(&x);
  print_line();
}

/**** удаление записи ****/
void fdel_item(int n) {
 long t;
 MON x;
  t=n; t*=SMON;
  lseek(file,t,SEEK_SET);
  while (read(file,&x,SMON)) {
    t=lseek(file,t-SMON,SEEK_SET);
    write(file,&x,SMON);
    t=tell(file);
    t=lseek(file,SMON,SEEK_CUR);
    }
  chsize(file,t-SMON);
}
</pre>

  <h4>5.4. Отладка программы</h4>
  <p>Методика отладки программы - такая же, как и в работе ╧14.</p>

  <h4>5.5. Результаты работы программы</h4>
  <p>Программа работает в интерактивном режиме, значит, объем информации, 
    которой обменивается программа и оператор, достаточно большой. Поэтому мы не 
    приводим образцы выполнения программы. В правильном выполнении программы можно 
    убедится наглядно.</p>
  <h4>5.6. Выводы</h4>
  <p>При выполнении лабораторной работы изучены вопросы:</p>
<ul>
  <li> конструирования многомодульных программ и их реализация в системе программирования 
    Borland C++;</li>
  <li>прямого файлового ввода-вывода. </li>
</ul>
<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l5.html>Назад</a></td><td><a href=index.html>Оглавление</a></td>
</tr>
</table>
</p>
<hr>
</body>
</html>
