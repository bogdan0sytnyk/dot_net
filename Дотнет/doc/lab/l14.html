<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, C">

<title>Основы программирования. Лабораторные работы </title>
<!--                                                                   -->
<!-- (C) Owner: Alexander S. Derevjanko -->
<!-- (C) ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l13.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l15.html>Вперед</a></td></tr>
</table>
</p>
<hr>
<h2 align=center>Лабораторная работа ╧14</h2>

<h2 align=center>Конструирование программ из нескольких файлов </h2>

<h3 align=center>1. Цель работы</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Целью лабораторной работы является получение практических навыков в работе с функциями и модульной структурой программы.

<h3 align=center>2. Темы для предварительной проработки </h3>
<ul>
<li>Массивы структур.
<li>Функции пользователя
<li>Создание программных проектов
</ul>

<h3 align=center>3. Задания для выполнения</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Для данных, которые обрабатывались в лабораторных работах ╧2 и ╧10, разработать программу, которая обеспечивает:<ul>
<li>добавление новых строк в таблицу;
<li>удаление строки с заданным номером из таблицы;
<li>вывод на экран информации, которая сохраняется в строке с заданным номером;
<li>вывод на экран всей таблицы.
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Программа должна состоять, как минимум, из двух файлов: в первом файле должна находится главная программа, функция которой - выбор в диалоговом режиме одного из вышеприведенных действий, во втором файле - функции, которые реализуют эти действия.

<h3 align=center>4. Варианты индивидуальных заданий</h3>

<p><table align=center>
<tr><td>&nbsp;<a href=v02_01.html>1</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_02.html>2</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_03.html>3</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_04.html>4</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_05.html>5</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_06.html>6</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_07.html>7</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_08.html>8</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_09.html>9</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_10.html>10</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v02_11.html>11</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_12.html>12</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_13.html>13</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_14.html>14</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_15.html>15</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_16.html>16</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_17.html>17</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_18.html>18</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_19.html>19</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_20.html>20</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v02_21.html>21</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_22.html>22</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_23.html>23</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_24.html>24</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_25.html>25</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_26.html>26</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_27.html>27</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_28.html>28</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_29.html>29</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_30.html>30</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table>
</p>

<h3 align=center>5. Пример решения задачи (вариант 30)</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Решение приводится со ссылками на работы 
<a href=l02.html>╧2</a>, <a href=l02.html>╧10</a>.

<h4 align=center>5.1. Определение основных переменных программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Условия задания позволяют использовать в этой работе "наследство" от работы ╧10. И прежде всего это - описания элемента массива, который представляется в виде структуры:
<pre>
    struct mon { . . . }; 
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Поскольку условия задания требуют создания программного изделия из нескольких файлов, выделим это описание в отдельный файл-заголовок, который будет включаться (<b><i>#include</I></b>) во все файлы программы. Это обеспечит одинаковость этой структуры данных во всех модулях. Для сокращения записи определим также сокращенные имена для этой структуры и для ее размера:
<pre>
    #define MON struct mon
    #define SMON sizeof(struct mon)
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Так же, как и в работе ╧10, данные в оперативной памяти будут находиться в массиве:
<pre>
    MON mmm[N]; 
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Размерность массива мы определим через макроконстанту:
<pre>
    #define N 100
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Кроме того, что этот массив должен размещаться в оперативной памяти, он еще должен быть доступным для нескольких модулей программы. Следовательно, в одном модуле этот массив должен быть определен, как показано выше, вне блоков, а в других модулях, которые к нему обращаются - только описан как внешний:
<pre>
    extern MON mmm[]; 
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;То же относится и к переменной, которая сохраняет количество информативных элементов в массиве: она должна быть определена в одном модуле:
<pre>
    int n;    
</pre>
и описана как внешняя в других:
<pre>
    extern int n;    
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Предполагается, что этим будет исчерпан список тех структур данных и переменных, которые будут общими для всех модулей программы.

<h4 align=center>5.2. Разработка программных модулей</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.2.1. Структура программы</b>

<br>&nbsp;&nbsp;&nbsp;&nbsp;Ниже приведено описание программы, подобное тем, которые мы давали в предыдущих работах, но тут оно дается отдельно для каждого программного модуля (разработка алгоритма, определение переменных, разработка текста), а для модулей, в которых содержится несколько функций, - для каждой функции.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Но прежде всего мы должны определить модульный состав программы.
Согласно условию, отдельный модуль должна составлять главная функция. Это соответствует некоторым общепринятыми подходами к конструированию программ: в таком модуле размещается программа-монитор, которая управляет порядком выполнения функций программного изделия. При необходимости изменить порядок их выполнения может быть разработан новый модуль-монитор при сохранении других модулей. В мониторе, как в наиболее общей составной части программы, могут быть определены также все глобальные переменные программы. Назовем текстовый модуль этой части программы: L14.C.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Хотя условия требуют еще только одного модуля, мы введем их два. Разделение функций между первым и вторым модулем произведем по такому принципу: в первом (<b><i>L14-1.C</I></b>) определим те функции, которые обращаются к глобальным переменным, а во втором (<b><i>L14-2.C</I></b>) - те, которые не зависят от них. 
<br>&nbsp;&nbsp;&nbsp;&nbsp;Сразу же договоримся, что для каждого программного модуля ми сделаем еще  и файл-заголовок (<b><i>L14-1.H</I></b>  и <b><i>L14-2.H</I></b>), в котором поместим описания всех функций, которые в этом модуле определены.

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.2.2. Модуль L14.C</b>

<br>&nbsp;&nbsp;&nbsp;&nbsp;Прежде всего, в этом модуле должны быть определены глобальные переменные программы и функция <b><i>main()</I></b>.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Локальные переменные функции <b><i>main()</I></b>: переменная <b><i>op</I></b>, в которую будет вводиться код того действия, которое должно выполнятся программой; <b><i>num</I></b> - номер записи для тех действий, которые его требуют; <b><i>eoj</I></b> - признак конца работы. Хотя алгоритм функции <b><i>main()</I></b> очень прост, мы приводим его схему (рисунок 1), потому что в соответствии с методом проектирования "сверху вниз" при его разработке определяются уточненные спецификации для других функций программы.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Описание алгоритма мы будем вести параллельно с описанием текста программы.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Начальное значение количества элементов в массиве должно быть 0 (блок 2), в программе это реализовано присваиванием начального значения переменной <b><i>n</I></b>. Признак конца устанавливается в 0 (блок 3), остальные блоки алгоритма (4 - 22) образуют цикл, который выполняется, пока этот признак не примет ненулевое значение. В программе начальная установка <b><i>eoj</I></b> и проверка предусловия цикла заложены в заголовке цикла <b><i>for</I></b>.
<br>&nbsp;&nbsp;&nbsp;&nbsp;В каждой итерации цикла программа выводит на экран меню - перечисление возможных действий (блок 5). Для удобства оператора каждому действию соответствует числовой код, вводя этот код (блок 6), оператор выбирает нужное действие. В программе это выполнено рядом обращений к функции <b><i>printf()</I></b> и вводом при помощи функции <b><i>scanf()</I></b> значения переменной <b><i>op</I></b>.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Остальная часть программного кода цикла разветвляется (блок 7) в зависимости от того, какое значение введено в переменную <b><i>op</I></b>. Поскольку разветвление имеет несколько ветвей, для его программной реализации удобно применить оператор <b><i>switch</I></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;При значении <b><i>op=0</I></b> (в программе - <b><i>case 0:</I></b>) достаточно установить в 1 признак конца работы (блок 8), тогда при следующей проверке предусловия произойдет выход из цикла.

<p><table align=center border><tr><td><img src=l14_e001.gif></td></tr><td>
Рис.1. Функция <b><i>main()</I></b>. Схема алгоритма</td></tr></table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;При значении <b><i>op=1</I></b> (в программе - <b><i>case 1: </I></b>) выполняется добавление в массив нового элемента. Для этого надо будет ввести с клавиатуры значения составных частей нового элемента и записать их в память - в первый свободный элемент массива. Вполне возможно, что операция ввода элемента может использоваться отдельно от хранения элементов в массиве. Поэтому предусмотрим функцию <b><i>ent_data</I></b> (), которая должна вводить новый элемент с клавиатуры (блок 9). Адрес памяти, по которому надо разместить введенный элемент, будет передаваться этой функции как параметр. В данном случае это будет адрес первого свободного элемента, который вычисляется как начальный адрес массива плюс количество элементов в массиве. Как мы установили еще в работе ╧10, оператор может отказаться от ввода или выполнить его с ошибками. Поэтому функция должна возвращать какое-то значение, из которого будет видно, выполнен ввод или нет, и это значение должно проверятся после обращения к функции (блок 10). Как это сделано во многих функциях библиотек языка C, пусть функция возвращает 0 при нормальном выполнении и какое-то отрицательное число - при ненормальном. Следовательно, условие нормального выполнения функции <b><i>ent_data()</I></b> в программе записывается как:
<pre>
    if (!ent_data(mmm+n)) . . . 
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Если ввод прошел нормально, количество элементов в массиве увеличивается (блок 11, в программе - <b><i>n++</I></b>) и на этом заканчивается ветвь выполнения (<b><i>break</I></b>) и выполнение итерации цикла.
<p>&nbsp;&nbsp;&nbsp;&nbsp;При значении <b><i>op=2</I></b> (в программе - <b><i>case 2:</I></b>) удаляется элемент из массива. Для этого прежде всего нужно ввести номер того элемента, который будет удаляться (блок 12). Для ввода номера предусмотрим функцию <b><i>get_number()</I></b>, которая будет запрашивать у оператора номер и вводить (возвращать) его. Введений оператором номер должен лежать в границах 1 - n, это надо проверить (блок 13). Для проверки предусмотрим функцию <b><i>check_number()</I></b>, которой будет передаваться номер, а она будет возвращать 0 или -1 - номер правильный/неправильный. В программе оба обращения и проверка результата закодированы одним оператором:
<pre>
    if (!check_number(num=get_number())) . . .
</pre>
который полностью реализует последовательность действий в блоках 12 - 14.
Если номер правильный, обращаемся к функции <b><i>del_item()</I></b>, которая удалит элемент из массива (блок 15). Этой функции нужно передать введений ранее номер элемента. Поскольку номер гарантированно правильный, никаких вариантов в работе этой функции быть не может, следовательно, нет нужды в возвращении функцией какого-либо значения. После выполнения функции уменьшаем на 1 количество элементов в массиве (блок 16).
<p>&nbsp;&nbsp;&nbsp;&nbsp;При значении <b><i>op=3</I></b> (в программе - <b><i>case 3:</I></b>) нужно вывести значение выбранного элемента. Для этого требуется сначала ввести и проверить номер элемента. Эти элементы схемы алгоритма (блоки 17 - 19) и соответствующая строка текста программы полностью аналогичны соответствующим действиям и для предыдущего случая. При вводе правильного номера обратимся к функции <b><I>show_1()</I></b> (блок 20), которая получит параметр - адрес элемента и выведет его на экран. Адрес элемента определяется как: <b><I>mmm+num-1</I></b>: имеем в виду, что для оператора нумерация элементов начинается с 1, а в массиве - с 0.
<p>&nbsp;&nbsp;&nbsp;&nbsp;При значении <b><I>op=4</I></b> (в программе - <b><I>case 4:</I></b>) нужно вывести весь массив. Это делаем обращением к функции <b><I>show_all</I></b> (блок 21).
<p>&nbsp;&nbsp;&nbsp;&nbsp;Следует предусмотреть также ввод оператором какого-то непредвиденного кода. В этом случае (в программе - <b><I>default</I></b>) следует вывести сообщение про ошибочный код (блок 22) и перейти на следующую итерацию цикла.
В тексте программы есть еще несколько строк, которые не предусмотрены в схеме алгоритма: в конце каждой итерации цикла происходит останов до нажатия оператором любой клавиши.
<p>&nbsp;&nbsp;&nbsp;&nbsp;В начало программного текста включаются (<b><I>#include</I></b>) файлы <b><I>stdio.h</I></b>, <b><I>conio.h</I></b> (в последнем описана функция <b><I>getch()</I></b>) и файлы с описаниями собственных функций. Первые два файла находятся в каталоге <b><i>H</I></b>-файлов системы программирования, два последние - в текущем каталоге.

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.2.3. Модуль L14-1.C</I></b>

<br>&nbsp;&nbsp;&nbsp;&nbsp;В этом модуле сосредоточены функции, которые иметь доступ к глобальным переменным программы - массива и количества элементов в нем. Поэтому в тексте этого модуля содержится описание внешних переменных, а также определения функций <b><i>check_number()</I></b>,<b><i>del_item()</I></b>,<b><i>show_all()</I></b>.
<br>&nbsp;&nbsp;&nbsp;&nbsp;В начало текста включаются также библиотечные файлы <b><i>stdio.h</I></b>, <b><i>mem.h</I></b> (описание функции <b><i>memcpy()</I></b>) и собственные файлы <b><i>l14.h</I></b> (описание структуры данных) и <b><i>l14-2.h</I></b> (описание функций пользователя, которые определены в файле <b><i>l14-2.C</I></b>).

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.2.3.1. Функция <i>check_number()</I>.</b> Функция выполняет проверку правильности номера элемента. Ее параметр - номер элемента. Функция возвращает <b><i>int</I></b> - 0, если номер элемента правильный, или - если неправильный.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Функция состоит и двух условных операторов. В первом проверяется, не меньше ли заданный номер 1. Если так, то выдается сообщение про ошибочный номер и функция возвращает -1.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Во втором условном операторе проверяется, не больше ли заданный номер n - количества элементов в массиве.  Если так, выдается сообщение про ошибочный номер и функция возвращает -1.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Если оба условия не выполняются, функция возвращает 0.

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.2.3.2. Функция <i>del_item()</I></b>. Функция выполняет удаление элемента с заданным номером из массива. Ее параметр - номер элемента. Функция не возвращает никакого значения.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Выполнение функции состоит из единственного оператора цикла, в котором перебираются элементы массива, начиная с заданного. В каждой итерации следующий элемент переписывается на место текущего. Таким образом, заданный элемент пропадает, а все элементы, которые размещались справа от него сдвигаются на одно место влево. Перебор элементов выполняется модификацией адресов. Для перезаписи применяется библиотечная функция <b><i>memcpy()</i></b>.

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.2.3.3. Функция <i>show_all()</I></b>. Функция выполняет вывод на экран всего массива в форме таблицы. Она не имеет параметров и не возвращает значения.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Выполнение функции начинается с обращения к функции <b><i>print_head()</I></b>, которая выводит на экран заголовок таблицы. Далее в функции идет цикл, в котором перебираются все элементы массива, начиная с нулевого. В каждой итерации этого цикла - обращение к функции <b><i>show_row()</I></b>, которая выводит одну строку таблицы. Этой функции передается адрес текущего элемента массива. После выхода из цикла мы обращаемся к функции <b><i>print_line()</I></b> для вывода нижней линии таблицы.

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.2.4. Модуль <i>L14-2.C</i></b>

<br>&nbsp;&nbsp;&nbsp;&nbsp;Здесь определены функции, которые не зависят от общих переменных.
<p>&nbsp;&nbsp;&nbsp;&nbsp;В начало текста включаются также библиотечные файлы <b><i>stdio.h</I></b>, <b><i>string.h</I></b> (описание строковых функций) и собственные файлы <b><i>l14.h</I></b> (описание структуры данных) и <b><i>l14-2.h</I></b> (описание функций, которые определены ниже).

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.2.4.1. Функция <i>get_number()</I>.</b> Функция выполняет ввод с клавиатуры номера элемента массива. Она не имеет параметров, а возвращает <b><i>int</I></b> - введенное значение.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Выполнение функции состоит из вывода (<b><i>printf()</I></b></I></b>) приглашения на ввод и ввода (<b><i>scanf()</I></b>) значения.

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.2.4.2. Функция <i>ent_data()</I>.</b> Функция выполняет ввод с клавиатуры значений для одного элемента массива. Ее параметр - <b><i>MON*</I></b> - указатель на структуру-монастырь, в которую вводятся значения а возвращает она <b><i>int</I></b> - 0, если ввод произошел, отрицательное число - если нет.
<br>&nbsp;&nbsp;&nbsp;&nbsp;В основном код функции <b><i>ent_data()</I></b> тождественен аналогичным фрагментам кода в работах ╧╧ 2 и 10. Разница состоит в том, что тут мы вводим дополнительную проверку того, что значение кода школы, введенное оператором, лежит в допустимом диапазоне значений.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Функция возвращает -1, если оператором введено название <b><i>"***"</i></b> и -2, если допущена ошибка в коде школы.

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.2.4.3. Функция <i>show_1()</I>.</b> Функция выполняет вывод на экран одного элемента массива. Ее параметр - <b><i>MON*</I></b> - указатель на структуру-монастырь, значения которой выводятся, она не возвращает значения.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Выполнение функции состоит из ряда обращений к функции <b><i>printf()</I></b> для вывода значений всех составляющих структуры. При выводе школы анализируется ее код и, в зависимости от кода, выводится полное название школы. В конце функция обращается к функции <b><i>print_line()</I></b> для подчеркивания выведенного текста.

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.2.4.4. Функция <i>show_row()</i>.</b> Функция выполняет вывод на экран одной строки таблицы. (Фактически, она делает то же самое, что и функция <b><i>show_1()</I></b>, но в другом формате). Ее параметр - <b><i>MON*</I></b> - указатель на структуру-монастырь, значения которой выводятся, она не возвращает значения.
<br>&nbsp;&nbsp;&nbsp;&nbsp;Код функции - точная копия оператора вывода строки из работ ╧╧ 2 и 10. 

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.2.4.5. Функция <i>print_line()</i>.</b> Функция выполняет вывод на экран линии, которая подчеркивает таблицу. Она не имеет параметров и не возвращает значения. Функция состоит из единственного обращение к <b><I>printf()</I></b>.

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.2.4.6. Функция <I>print_head()</I>.</b> Функция выполняет вывод на экран заголовка таблицы. Она не имеет параметров и не возвращает значения. 
<br>&nbsp;&nbsp;&nbsp;&nbsp;Код функции - точная копия оператора вывод строки из работ ╧╧ 2 и 10.

<h4 align=center>5.4. Создание программного проекта</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Процесс подготовки программы, текст которой разделен на несколько файлов, показан на рисунке 2.

<p><table align=center border><tr><td><img src=l14_e002.gif></td></tr><td>
Рис.2. Проект программы из нескольких модулей</td></tr></table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Файлы, в которых содержится текст программы, - текстовые модули - имеют расширение <b><i>.C</I></b>. Каждый текстовый модуль компилируется отдельно. Результатом компиляции является файл - объектный модуль, имя которого совпадает с именем текстового модуля, а расширение - <b><i>.OBJ</I></b>. Следующий шаг - компоновка. На этом шаге из нескольких объектных модулей (а также из библиотечных модулей) создается единый загрузочный модуль. Но компоновщик для выполнения своей работы должен "знать", какие именно объектные модули следует включать в программу. Эта информация - перечень модулей, из которых складывается программа, - содержится в отдельном файле-проекте. Этот файл имеет произвольное имя и расширение <b><i>.PRJ</I></b>. Результатом работы компоновщика является файл, имя которого совпадает с именем проекта, а расширение - <b><i>.EXE</I></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;В системе программирования Borland C++ файл-проект создается самой системой программирования по указаниями программиста. Для создания проекту нужно выбрать: <b><i>Главное Меню -> Project -> Open Project... </I></b> Затем на экране появляется окно <b><i>Open Project File</I></b>, в котором можно выбрать уже существующий проект, или создать новый проект, вводя новое имя. Когда проект выбран/создан, на экране появляется окно <b><i>Project: <имя></I></b>, в котором отображен перечень модулей в составе проекта. Пользуясь функциональной клавиатурой можно добавить в проект новые модули или удалить какие-то модули. 
<p>&nbsp;&nbsp;&nbsp;&nbsp;Когда проект открыт, компоновщик в своей работе пользуется именно информацией, которая содержится в открытом проекте, независимо от того, какие файлы загружены в окнах редактирования. Для закрытия проекта нужно выбрать: <b><i>Главное Меню -> Project -> Close Project... </I></b>

<h4 align=center>5.5. Текст программы</h4>
<pre>
/*******************************************************/
/*               Лабораторная работа ╧14               */
/*   Конструирование программ из нескольких файлов     */
/*            Пример выполнения. Вариант ╧30.          */
/*******************************************************/
/*                      Файл L14.H                     */
/*******************************************************/
/* Описание структуры, представляющей монастырь */
#define MON struct mon
#define SMON sizeof(struct mon)
struct mon {
  char name[15]; /* название */
  char sc;       /* школа */
  int cnt;       /* количество монахов */
  float sq;      /* площа */
  };

/*******************************************************/
/*               Лабораторнаф работа ╧14               */
/*                    Файл L14-1.H                     */
/*******************************************************/
/* Описания функций файла L14-1.C */
int check_number(int);
void del_item(int);
void show_all(void);


/*******************************************************/
/*               Лабораторная работа ╧14               */
/*                    Файл L14-2.H                     */
/*******************************************************/
/* Описания функций файла L14-2.C */
void print_head(void);
void print_line(void);
void show_row(MON *);
int get_number(void);
void show_1(MON *);
int ent_data(MON *);

/*******************************************************/
/*               Лабораторная работа ╧14               */
/*                     Файл L14.C                      */
/*******************************************************/
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include "l14.h"
#include "l14-1.h"
#include "l14-2.h"
#define N 100
MON mmm[N]; /* массив-таблица */
int n=0;    /* количество элементов в массиве */

/**** главная функция ****/
int main(void) {
 int op;   /* операция */
 int num;  /* номер элемента */
 char eoj; /* признак конца */
  /*  */
  for (eoj=0; !eoj; ) {
    /* выводення меню */
    printf("1 - Добавить элемент\n");
    printf("2 - Удалить элемент\n");
    printf("3 - Показать элемент по номеру\n");
    printf("4 - Показать все\n");
    printf("0 - Выход\n");
    printf("Вводите &gt;");
    /* вибор из меню  */
    scanf("%d",&op);
    switch(op) {
      case 0: /* выход */
        eoj=1;
        break;
      case 1: /* добавить */
        if (!ent_data(mmm+n)) n++;
        break;
      case 2: /* удалить */
        if (!check_number(num=get_number())) {
          del_item(num);
          n--;
          }
        break;
      case 3: /* показать один */
        if (!check_number(num=get_number())) 
          show_1(mmm+num-1);
        break;
      case 4: /* показать все */
        show_all();
        break;
      default:
        printf("Неправильная операция\n");
        break;
      }  /* switch */
    if (op) {
      printf("Нажмите любую клавишу\n");
      getch();
      } /* if */
    } /* for */
  return 0;
}  /* main */

/*******************************************************/
/*               Лабораторная работа ╧14               */
/*                    Файл L14-1.C                     */
/*******************************************************/
/*  Функции, которые используют глобальные переменные  */
#include &lt;stdio.h&gt;
#include &lt;mem.h&gt;
#include "l14.h"
#include "l14-2.h"
extern MON mmm[];
extern int n;

/**** проверка номера элемента ****/
int check_number(int a) {
  if (a&lt;1) {
    printf("Минимальный номер : 1\n");
    return -1;
    }
  if (a&gt;n) {
    printf("Максимальный номер : %d\n",n);
    return -1;
    }
  return 0;
}

/**** удаление элемента ****/
void del_item(int m) {
 int i;
  for (; m&lt;n; m++)
    memcpy(mmm+m-1,mmm+m,SMON);
}

/**** выво всего массива ****/
void show_all() {
 int i;
  print_head();
  for (i=0; i&lt;n; i++)
    show_row(mmm+i);
  print_line();
}

/*******************************************************/
/*               Лабораторная работа ╧14               */
/*                    Файл L14-2.C                     */
/*******************************************************/
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "l14.h"
#include "l14-2.h"

/****  ввод номера ****/
int get_number() {
 int b;
  printf("Введите номер&gt;");
  scanf("%d",&b);
  return b;
}

/**** ввод данных про один монастырь ***/
int ent_data(MON *m) {
 float sqx;
  /* Ввод данных */
  printf("Введите название, школу, количество, площадь&gt;");
  scanf("%s %c %d %f",m-&gt;name,&m-&gt;sc,&m-&gt;cnt,&sqx);
  m-&gt;sq=sqx;
  if (!strcmp(m-&gt;name,"***")) return -1;
  if (strchr("ТСД",m-&gt;sc)==NULL) {
    printf("Ошибка\n");
    return -2;
    }
  return 0;
}

/**** вывод данных про один монастырь ***/
void show_1(MON *m) {
  printf("\nНазвание           : %s\n",m-&gt;name);
  printf("Школа              : ");
  switch(m-&gt;sc) {
    case 'Т': printf("Тендай"); break;
    case 'С': printf("Сингон"); break;

    case 'Д': printf("Дзедзицу"); break;
    }
  printf("\nКоличество монахов : %d\n",m-&gt;cnt);
  printf("Площадь земель     : %6.2f\n",m-&gt;sq);
  print_line();
}

/**** вывод строки таблицы ****/
void show_row(MON *m) {
  printf("| %9s |   %c   |       %3d | %-5.1f       |\n",
    m-&gt;name,m-&gt;sc,m-&gt;cnt,m-&gt;sq);
}

/**** вывод подчеркивания ****/
void print_line() {
  printf("-----------------------------------------------\n");
  }

/**** вывод заголовка таблицы ****/
void print_head() {
  print_line();
  printf("|Буддийские монастыри Японии периода Нара     |\n");
  printf("|---------------------------------------------|\n");
  printf("| Название  | Школа | Количество| Площадь     |\n");
  printf("|           |       | монахов   | земель (га) |\n");
  printf("|-----------|-------|-----------|-------------|\n");
}
</pre>

<h4 align=center>5.4. Отладка программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Отладку программы следует вести поэтапно - "сверху вниз": сначала убедиться в правильном выполнении монитора (функции <b><i>main()</I></b>), который управляет порядком выполнения остальных функций, а потом по очереди проверять остальные функции, начиная, конечно, с функции ввода значений. При проверке работы удаления необходимо обязательно убедиться в правильном его функционировании при удалении первого и последнего элементов. 
<p>&nbsp;&nbsp;&nbsp;&nbsp;При отладке программы можно использовать пошаговый режим. При этом следует отслеживать переход управления в функции (<b><i>F7</I></b>). При отладке отдельных функций целесообразно устанавливать точку останова на входе той функции, которая сейчас отлаживается, до этой точки выполнять программу в автоматическом режиме, а после нее - шаг за шагом.


<h4 align=center>5.5. Результаты работы программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Программа работает в интерактивном режиме, следовательно, объем информации, которой обмениваются программа и оператор достаточно большой. Поэтому мы не приводимо образцов выполнения программы. В правильном выполнении программы можно убедиться наглядно.

<h4 align=center>5.6. Выводы
</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;При выполнении лабораторной работы изучены вопросы:
<ul>
<li>конструирования многомодульных программ их реализации в системе программирования Borland C++.
</ul>

<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l13.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l15.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>
