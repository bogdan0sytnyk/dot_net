<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, C">

<title>Основы программирования. Лабораторные работы </title>
<!--                                                                   -->
<!-- (C) Owner: Alexander S. Derevjanko -->
<!-- (C) ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l09.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l11.html>Вперед</a></td></tr>
</table>
</p>
<hr>
<h2 align=center>Лабораторная работа ╧10</h2>

<h2 align=center>Структуры и массивы структур</h2>


<h3 align=center>1. Цель работы</h3>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Целью лабораторной работы является получение практических навыков в работе с интегрированными типами данных - структурами и массивами структур языка C.

<h3 align=center>2. Темы для предварительной проработки</h3>
<ul>
<li>Типы данных языка C.
<li>Массивы.
<li>Структуры.
</ul>

<h3 align=center>3. Задания для выполнения</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Составить программу, в которой будут вводиться 7 - 10 строк таблицы, образец которой приведен в Вашем варианте индивидуального задания к лабораторной работе ╧2 и выводится на экран таблица - сразу же после ввода и после сортировки ее по значениям в первом столбце. Примечания к таблице, которые есть в работе ╧2, можно не выводить.

<h3 align=center>4. Варианты индивидуальных заданий </h3>

<p><table align=center>
<tr><td>&nbsp;<a href=v02_01.html>1</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_02.html>2</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_03.html>3</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_04.html>4</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_05.html>5</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_06.html>6</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_07.html>7</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_08.html>8</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v02_09.html>9</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_10.html>10</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v02_11.html>11</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_12.html>12</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_13.html>13</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_14.html>14</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_15.html>15</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_16.html>16</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_17.html>17</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_18.html>18</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_19.html>19</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_20.html>20</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v02_21.html>21</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_22.html>22</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_23.html>23</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_24.html>24</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_25.html>25</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_26.html>26</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_27.html>27</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_28.html>28</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_29.html>29</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v02_30.html>30</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table>
</p>

<h3 align=center>5. Пример решения задачи (вариант 30)</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Решения приводится со ссылками на работу 
<a href=l02.html>╧2</a>.

<h4 align=center>5.1. Разработка алгоритма решения.</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Алгоритм решения, приведенный на рисунке ниже, является типовым алгоритмом обработки массива, элементами которого являются описания монастырей. 
<p><table align=center border><tr><td><img src=l10_1.gif></td></tr></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Алгоритм начинается с ввода значений элементов этого массива. Ввод происходит в цикле со счетчиком <b><i>n</i></b>, который изменяется от 0 до 9 (блок 2), но как мы увидим ниже, выход из цикла может происходить и до того, как счетчик достигнет последнего значения. В каждой итерации циклу выводится приглашение (блок 3) и вводятся значения составных частей описания монастыря (блоки 4, 6, 7, 8). Но сразу же после ввода первой составляющей - названия - проверяется ее значения (блок 5). Если введено название <b><i>"***"</i></b>, то дальнейшего ввода не происходит, а сразу выполняется выход из цикла. В любом случае после выхода в переменной <b><i>n</i></b> остается количество введенных элементов. Таким образом, программа может обрабатывать массив из 10 или меньше элементов - сколько их было введено. Признаком конца ввода является название <b><i>"***"</i></b>.


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее печатаем заголовок таблицы (блок 9) и в цикле (блоки 10, 11) - строки таблицы с данными. Поскольку параметр этого цикла изменяется от <b><i>0</i></b> до <b><i>n-1</i></b>, будет напечатано <b><i>n</i></b> строк.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следующий сложный цикл реализует сортировку таблицы по алгоритму простой обменной выборки. Сортировка выполняется с помощью вложенного цикла (блок 12). В первой итерации внешнего цикла выполняется поиск элемента массива с минимальным значением поля <b><i>name</i></b>. Для этого сначала минимальным элементом считается первый элемент (блок 13). Потом в цикле (блок 14) пересматриваются остальные элементы массива, и каждый сравнивается с минимальным (блок 15). Если поле <b><i>name</i></b> очередного элемента меньше, чем минимального, то теперь этот элемент считается минимальным (блок 16). Индекс минимального элемента записывается в переменную <b><i>m</i></b>. После выхода из внутреннего цикла, если найденный минимальный элемент не первый (блок 17), то он меняется местами с первым (блок 18). Таким образом, минимальный элемент массива становится на свое место. В следующей итерации внешнего цикла выполняется поиск минимума среди элементов массива, начиная со второго, в третьей - начиная с третьего и т.д. После выхода из внешнего цикла массив оказывается отсортированным.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вывод отсортированного массива (блоки 19 - 21) происходит точно так же, как и вывод начального массива (блоки 9 - 11).

<h4 align=center>5.2. Определение переменных программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как мы отметили, элементом массива является описание объекта. Поскольку описание состоит из нескольких составных частей разного типа, для него используем структуру языка C. Описание этой структуры будет иметь вид: 
<pre>
    struct mon {
      char name[15]; /* название */
      char sc;       /* школа */
      int cnt;       /* количество монахов */
      float sq;      /* площадь */
      }; 
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Тут мы резервируем для названия больше символов, чем в работе ╧2, предвидя возможность появления более длинных названий, а также даем тип <b><i>int</i></b> полю <b><i>cnt</i></b>, допуская, что его значения может быть больше, чем 255.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Нам нужно будет иметь массив элементов указанного типа, следовательно, объявляем:
<pre>
   struct mon mm[10];
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для выполнения перестановки элементов массива нужна будет еще рабочая область памяти того же типа, что и элементы массива, поэтому вводимо еще:
<pre>
    struct mon x;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как видно из схемы алгоритма, нужны будут переменные целого типа для: количества введенных элементов <b><i>n</i></b>, индексов внешнего (<b><i>i</i></b>) и внутреннего (<b><i>j</i></b>) циклов и индекса минимального элемента - <b><i>m</i></b>. Поэтому объявляем:
<pre>
    int i, j, n, m;
</pre>

<h4 align=center>5.3. Разработка текста программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Текст программы начинаем с включения файла <b><i>stdio.h</i></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Поскольку нам придется проводить сравнение (блок 15) поля <b><i>name</i></b> в элементах массива, а это поле - символьная строка, включаем также файл <b><i>string.h</i></b>, где описаны функции работы с символьными строками. В самом начале программы вводим также описание структуры <b><i>mon</i></b> и одновременно - объявление массива <b><i>mm</i></b>. Массив будет размещен в статической памяти.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Потом открывается главная функция программы, и в ней объявляются остальные переменные. Объявление:
<pre>
    float sqx; 
</pre>
мы прокомментируем ниже.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Открывается простой цикл со счетчиком <b><i>n</i></b>, в каждой итерации цикла выводится приглашение и вводятся значения полей очередного элемента массива. Сравнение поля <b><i>name</i></b> с константой <b><i>"***"</i></b> - признаком конца ввода выполняется с помощью функции <b><i>strcmp()</i></b>. Если введен признак конца, происходит досрочный выход из цикла за оператором <b><i>break</i></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следует, однако, остановиться на вводе значения для поля <b><i>sq</i></b>. Тут мы столкнулись (не впервые в нашей практике) с явлением, которое не можем объяснить иначе, чем ошибкой в системе программирования: функция <b><i>scanf()</i></b> работает ненадежно при вводе значений типа <b><i>float</i></b> и <b><i>double</i></b>, если это - значения полей элементов массива структур. Поэтому мы объявили рабочую переменную <b><i>sqx</i></b> типа <b><i>float</i></b> и значение поля <b><i>sq</i></b> сначала вводится в эту переменную, а потом присваивается полю структуры.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вывод массива состоит из вывода заголовка как нескольких строк-констант и вывода в цикле строк с фактическими данными - так же, как в работе ╧2.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следующие операторы программы подробно реализуют блоки 12 - 17 схемы алгоритма (для сравнения символьных строк применяется функция <b><i>strcmp()</i></b>). Детального рассмотрения требует только реализация блока 18 - перестановка элементов. Во-первых, при перестановке используется рабочая структура <b><i>x</i></b>: сначала содержимое <b><i>i</i></b>-го элемента пересылается в <b><i>x</i></b>, потом содержимое <b><i>m</i></b>-го элемента пересылается в <b><i>i</i></b>-ый элемент, а потом содержимое <b><i>x</i></b> пересылается в <b><i>m</i></b>-ый элемент. Во-вторых, операция присваивания, которая обычно применяется для пересылки значений, не может применяться к структуре в целом, так что присваивания происходит для каждого поля отдельно. К тому же, поле <b><i>name</i></b> является символьной строкой, а строки тоже не могут присваиваться прямо, а только - через функцию <b><i>strcpy()</i></b>. (Впрочем, для присваивания структур можно использовать функцию пересылки в памяти - <b><i>memcpy().</i></b>)
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вывод таблицы-результата - такой же, как и начальной таблицы.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Полный текст программы приведен ниже.

<pre>
/********************************************************/
/*                Лабораторная работа ╧10               */
/*               Структуры и массивы структур           */
/*              Пример выполнения. ВарЁант ╧30.         */
/********************************************************/
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
/* Описание структуры, которая представляет монастырь */
struct mon {
  char name[15]; /* название */
  char sc;       /* школа */
  int cnt;       /* количество монахов */
  float sq;      /* площадь */
  } mm[10]; /* определение массива монастирей */
int main(void) {
 struct mmm x; /* рабочая переменная */
 int n;    /* количество элементов в массиве */
 int i, j; /* текущие индексы в массиве */
 int m;    /* индекс минимального элемента */
 float sqx;/* рабочая переменная */
  /* Ввод данных */
  for (n=0; n&lt;10; n++){
    printf("%d. Введите: название, школу, количество, площадь &gt;", 
      n+1);
    scanf("%s",mm[n].name);
    if (!strcmp(mm[n].name,"***")) break;
    scanf("%s",&mm[n].sc);
    scanf("%d",&mm[n].cnt);
    /* Внимание! Мы обходим ошибку в системе программирования */
    scanf("%f",&sqx); mm[n].sq=sqx;
    }
  /* Вывод таблицы */
  printf("---------------------------------------------\n");
  printf("|Буддийське монастыри Японии перiода Нара    |\n");
  printf("|--------------------------------------------|\n");
  printf("| Название  | Школа |Количество|   Площадь   |\n");
  printf("|           |       |  монахов | земель(га)  |\n");
  printf("|-----------|-------|----------|-------------|\n");
  /* вывод строк фактических данных */
  for (i=0; i&lt;n; i++)
    printf("| %9s |   %c   |       %3d | %-5.1f       |\n",
      mm[i].name,mm[i].sc,mm[i].cnt,mm[i].sq);
  printf("---------------------------------------------\n");
  /* сортировка массива */
  for (i=0; i&lt;n-1; i++) {
    m=i; /* минимальный элемент - первый */
    for (j=i+1; j&lt;n; j++)
      /* если текущий элемент &gt; минимального, 
         он становится минимальным */
      if (strcmp(mm[m].name,mm[j].name)&gt;0) m=j;
    if (m&gt;i) {
      /* перестановка первого и минимального элементов */
      strcpy(x.name,mm[i].name); x.sc=mm[i].sc;
      x.cnt=mm[i].cnt; x.sq=mm[i].sq;
      strcpy(mm[i].name,mm[m].name); mm[i].sc=mm[m].sc;
      mm[i].cnt=mm[m].cnt; mm[i].sq=mm[m].sq;
      strcpy(mm[m].name,x.name); mm[m].sc=x.sc;
      mm[m].cnt=x.cnt; mm[m].sq=x.sq;
      }
    }
  /* Вывод таблицы */
  printf("---------------------------------------------\n");
  printf("|Буддийське монастыри Японии перiода Нара    |\n");
  printf("|--------------------------------------------|\n");
  printf("| Название  | Школа |Количество|   Площадь   |\n");
  printf("|           |       |  монахов | земель(га)  |\n");
  printf("|-----------|-------|----------|-------------|\n");
   for (i=0; i&lt;n; i++)
    printf("| %9s |   %c   |       %3d | %-5.1f       |\n",
      mm[i].name,mm[i].sc,mm[i].cnt,mm[i].sq);
  printf("---------------------------------------------\n");
  return 0;
}
</pre>


<h4 align=center>5.4. Отладка программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При отладке программы можно использовать пошаговый режим с отслеживанием значений переменных - тех, которые вводятся. Если возникают проблемы с вводом переменных, целесообразно вводить каждую переменную отдельным оператором.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Самой сложной может быть отладка той части программы, которая выполняет сортировку массива. Пересмотр всего массива структур средствами отладчика системы программирования хотя и возможен, но может быть достаточно громоздким. Поэтому лучше при ошибках в этой части программы вставить промежуточные выводы - например, выводить всю таблицу после каждого цикла сортировки. В пошаговом режиме можно наблюдать значение найденного минимума в каждом циклЁ.

<h4 align=center>5.5. Результаты работы программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При работе программы на экран было выведено следующее:

<pre>
1. Введите: название, школу, количество, площадь &gt; Тодайдзи Т 220 368.8  
2. Введите: название, школу, количество, площадь &gt; Якусидзи С 50 54.7       
3. Введите: название, школу, количество, площадь &gt; Дайаедзи Д 10 12.2       
-----------------------------------------------
|Буддийские монастыри Японии периода Нара     |
|---------------------------------------------|
| Название  | Школа | Количество| Площадь     |
|           |       | монахов   | земель(га)  |
|-----------|-------|-----------|-------------|
|  Тодайдзи |   Т   |       220 | 368.8       |
|  Якусидзи |   С   |        50 |  54.7       |
|  Дайаедзи |   Д   |        10 |  12.2       |
-----------------------------------------------
</pre>

<h4 align=center>5.6. Выводы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При выполнении лабораторной работы изучены вопросы:
<ul>
<li>структуры и массивы структур в языке C.
</ul>
<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l09.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l11.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>


