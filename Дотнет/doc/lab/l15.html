<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, C">

<title>Основы программирования. Лабораторные работы </title>
<!--                                                                   -->
<!-- (C) Owner: Alexander S. Derevjanko -->
<!-- (C) ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l14.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l16.html>Вперед</a></td></tr>
</table>
</p>
<hr>
<h2 align=center>Лабораторная работа ╧15</h2>
<h2 align=center>Форматный файловый ввода-вывода</h2>

<h3 align=center>1. Цель работы</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Целью лабораторной работы является получение практических навыков в работе с файловыми функциями форматного ввода-вывода.

<h3 align=center>2. Темы для предварительной проработки </h3>

<ul>
<li>Функции форматного файлового ввода-вывода.
<li>Указатели и массивы.
</ul>

<h3 align=center>3. Задание для выполнения</h3>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Составить программу, которая читает текстовый файл и выполняет такое преобразование его, какое задано в Вашем варианте индивидуального задания.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Примечания:
<ol>
<li>Имя файла, который подлежит обработке, должно быть параметром программы.
<li>Файл должен иметь не менее 10-15 строк текста.
<li>Допускается ограничить максимальную длину строки в тексте 80 символами.
<li>Допускается (если в индивидуальном задании не оговорено другое) считать, что слова разделяются пробелами, а знаки препинания рассматривать как буквы.
<li>Программу следует разрабатывать, исходя из предположения, что весь текст из файла не может быть размещен в оперативной памяти. 
<li>Допускается создавать при выполнении программы временные файлы, которые, однако, не должны сохранятся после окончания программы.
</ol>

<h3 align=center>4. Варианты индивидуальных заданий</h3>
<p><table align=center>
<tr><td>&nbsp;<a href=v15_01.html>1</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v15_02.html>2</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v15_03.html>3</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v15_04.html>4</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v15_05.html>5</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v15_06.html>6</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v15_07.html>7</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v15_08.html>8</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v15_09.html>9</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_10.html>10</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v15_11.html>11</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_12.html>12</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_13.html>13</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_14.html>14</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_15.html>15</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_16.html>16</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_17.html>17</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_18.html>18</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_19.html>19</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_20.html>20</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v15_21.html>21</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_22.html>22</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_23.html>23</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_24.html>24</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_25.html>25</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_26.html>26</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_27.html>27</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_28.html>28</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_29.html>29</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v15_30.html>30</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table>
</p>

<h3 align=center>5. Пример решения задачи (вариант 30)</h3>

<h4 align=center>5.1. Разработка алгоритма решения.</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.1.1.Общий алгоритм</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;Условия задания требуют выровнять все строки до размера самой длинной строки во всем файле. Следовательно, для решения задачи придется прочитать файл, как минимум, дважды - при первом чтении (первая фаза программы) определить максимальную длину строки, а при втором (вторая фаза программы) - выполнять заданные преобразования. Но достаточно ли будет при первом чтении просто определять длину строки? В строке могут быть лишние пробелы, которые при выравнивании будут удалены, так что простого определения длины (например, при помощи функции <b><I>strlen()</i></b>) недостаточно - следует при определении длины принять во внимание и пробелы, что будет требовать посимвольного просмотра всей строки. Если мы в первой фазе будем только подсчитывать лишние пробелы, то во второй фазе нам в значительной степени придется повторить эту работу, чтоб избавиться от этих лишних пробелов - так почему бы не выполнить всю эту работу в первой фазе? Выравнивание во второй фазе будет выполняться добавлением пробелов между словами, так что нам нужно будет знать количество слов В каждой строке - его можно определить в том же просмотре строки, когда мы удаляем лишние пробелы, т.е. в первой фазе.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Таким образом, мы приходим к двухфазной схеме программы, когда в первой фазе выполняется какая-то часть обработки и получается промежуточный результат. Этот промежуточный результат является входными данными для второй фазы, которая выполняет окончательную обработку и формирует конечный результат. 
<p>&nbsp;&nbsp;&nbsp;&nbsp;Промежуточный результат первой фазы состоит из:
<ul>
<li>максимальной длины строки в файле;
<li>всех строк файла, из которых удалены лишние пробелы;
<li>количества слов для каждого строки файла.
</ul>
&nbsp;&nbsp;&nbsp;&nbsp;Если первая составная часть промежуточного результата - одно число, которое может сохраняться в переменной программы и через нее передаваться от первой фазы во вторую, то остальные составляющие требуют для своего сохранения файл. Следовательно, программа будет выполняться, как показано на рис.1

<p><table border align=center>
<tr><td><img src=l15_e001.gif></td></tr><td>
Рис.1. Двухфазное выполнение программы</td></tr>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Общий алгоритм выполнения программы (без детализации выполнения первой и второй фаз) показан на рис.2.

<p><table border align=center>
<tr><td><img src=l15_e002.gif></td></tr><td></td></tr>
Рис.2. Схема алгоритма
</table><p>&nbsp;&nbsp;&nbsp;&nbsp;Алгоритм программы, на наш взгляд, достаточно понятен из приведенной схемы, обратим внимание только на некоторые особенности, которые не были упомянуты ране или не детализированы на схеме алгоритма. 
<p>&nbsp;&nbsp;&nbsp;&nbsp;Отметим, что на схеме приняты такие обозначения для переменных алгоритма: <b><I>inf</i></b> и <b><I>outf</i></b> - файловые переменные, которые представляют входной и выходной файлы соответственно; <b><I>l</i></b> - длина текущей строки, <b><I>lmax</i></b> - длина самой длинной строки в файле; <b><I>nw</i></b> -  количество слов в текущей строке.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Программа должна получать имя файла как свой параметр. Поэтому выполнение программы должно начинаться (блок 1) с проверки того, задан ли этот параметр. Если параметр не задан, программа должна завершаться.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Открытие файлов (блоки 3 и 13) должно сопровождаться проверкой успешности открытия. Если открытие неуспешно (причиной этого может быть, например, неправильно заданное имя файла), программа должна завершаться.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Та обработка строк, которую выполняют две фазы программы на рис.2, не детализирована - подробно мы раскроем эти фазы ниже.
<p>&nbsp;&nbsp;&nbsp;&nbsp;При первом чтении файла выполняется определение максимальной длины строки - на схеме алгоритма это блоки 4 и 9 - 11.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Алгоритм второго чтения (блоки 13 - 20) предусматривает некоторые обстоятельства, которые мы ранее не рассмотрели. Выравнивание будет вестись вставкой дополнительных пробелов между словами. Но что делать, если строка состоит из единственного слова или вообще пустая? Задание не предусматривает ничего по этому поводу - принимаем решение, что такая строка будет выводиться без выравнивания, только с удалением лишних пробелов. Обработка строки на второй фазе будет, очевидно, происходить таким образом, что прочитанная строка будет сохраняться в каком-то входном буфере, а строка-результат будет формироваться в выходном буфере. Следовательно, если количество слов в строке больше одного (блок 16), выполняется обработка фазы 2 и в выходной файл выводится строка из выходного буфера (блоки 17, 18). Если же в строке одно слово или совсем ничего нет, строка из входного буфера без обработки выводится в выходной файл (блок 19).
<p>&nbsp;&nbsp;&nbsp;&nbsp;Обратите внимание также на то, что перед завершением программы временный файл для сохранения промежуточного результата уничтожается (блок 21).

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.1.2. Алгоритм выполнения первой фазы</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;Детализируем теперь ту обработку каждого строки, которая выполняется на первой фазе, - рисунок 3. Имея в виду то, что реализация алгоритма буде выполнена на языке C, мы уже при составлении его учитываем возможности языка в отношении использования указателей при работе со строками.


<p><table border align=center>
<tr><td><img src=l15_e003.gif></td></tr><td>
Рис.3. Первая фаза. Схема алгоритма.</td></tr>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Та обработка, которую мы должны выполнить, включает в себя удаление двойных пробелов и подсчет количества слов. Для обеих задач нам нужно сравнивать два соседних символа в строке. К текущему символу мы будем обращаться через указатель, а предыдущий символ будет сохраняться в переменной <b><I>os</i></b>. Для самого первого символа строки значение предыдущего символа - пробел, начальное значение количества слов - <b><I>nw</i></b> - 0 (блок 2). 
Строка из файла считывается в буфер в оперативной памяти, при ее посимвольном просмотре мы будем формировать выходную строку в втором буфере. Указатели <b><I>b1</i></b> и <b><I>b2</i></b> устанавливаются на начало входного и выходного буферов соответственно (блок 3).
<p>&nbsp;&nbsp;&nbsp;&nbsp;Обработка строки будет вестись в цикле (блоки 4 - 10). Условием выхода из цикла является достижение конца строки во входном буфере, это выяснится, когда мы найдем во входном буфере символ с кодом 0 (блок 4). В каждой итерации цикла мы первым делом проверяем текущий символ во входном буфере - тот, на который указывает указатель <b><I>b1</i></b> (блок 5). Если это символ перехода на новую строку - символ с кодом <b><I>0A<sub>16</sub></i></b> - мы не делаем ничего, сразу же переходим на конец цикла (блок 10). Если это пробел, проверяем (блок 6), не был ли пробелом предыдущий символ, если так, то переходим на конец цикла. Таким образом, повторные пробели и символы перехода просто не копируются в выходной буфер. Если пробел не повторный, он обрабатывается как любой второй символ. Обработка других символов начинается с проверки, не был ли пробелом предыдущий символ (блок 7). Такая ситуация является признаком начала нового слова и, если она обнаружена, счетчик слов увеличивается на 1 (блок 8). Потом символ из входного буфера пересылается в выходной и указатель в выходном буфере сдвигается на 1 (блок 9). На следующем блоке сходятся все ветви обработки: тот символ входного буфера, который был только что обработан, сохраняется как предыдущий символ и сдвигается указатель во входном буфере (блок 10). 
<p>&nbsp;&nbsp;&nbsp;&nbsp;После выхода из цикла нам нужно записать в выходной буфер признак конца строки - символ с кодом 0. Но нужно иметь в виду то, что мы можем иметь еще один лишний пробел в конце строки. Если выходная строка пустая (блок 11) или последний записанный в нее символ - не пробел (блок 12), признак конца записывается (блок 14) за последним символом строки (туда, куда показывает указатель <b><I>b2</i></b>). Если же последний символ - пробел, признак конца записывается вместо него (блок 13).

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>5.1.3. Алгоритм выполнения второй фазы</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;Цель этой фазы - выравнивание. Если обозначим ту длину строки, до которой должно происходить выравнивание, - <b><I>lmax</i></b>, а текущую длину - <b><I>l</i></b>, то для выравнивания в строку следует добавить <b><I>lmax-l</i></b> пробелов. Эти пробелы должны быть равномерно распределены в <b><I>nw-1</i></b> промежутках между словами. Следовательно, количество пробелов, которое следует добавлять в каждый промежуток - <b><I>nb=(lmax-l)/(nw-1) </i></b>. Но операция деления может давать результат с дробной частью. Следовательно, для точного выравнивания в несколько промежутков в начале строки будут добавляться <b><I>nb</i></b> пробелов (и игнорированием дробной части <b><I>nb) </i></b>, а в остальные промежутки - на 1 большее количество, так чтобы итоговая длина строки была равна точно <b><I>lmax</i></b>. Количество последних промежутков равно остатку от деления. Другой способ точного определения требуемого количества пробелов для каждого промежутка - пересчитывать <b><I>nb</i></b> для каждого следующего промежутка с учетом количества уже обработанных символов строки, именно такой способ предлагается в алгоритме, схема которого приведена на рисунке 4.

<p><table border align=center>
<tr><td><img src=l15_e004.gif></td></tr><td>
Рис.4. Вторая фаза. Схема алгоритма. </td></tr>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<b><I>nb</i></b> определяется (блок 2), как было показано выше. Выше мы также приняли такой вариант определения точного количества пробелов, который предусматривает переопределение <b><I>nb</i></b>. При этом переопределении нужно будет корректировать значения <b><I>l</i></b> и <b><I>lmax</i></b>, поэтому делаем копию значения <b><I>lmax</i></b> в переменной <b><I>lm</i></b> (блок 3), именно эту копию мы и будем изменять. Потом устанавливаем указатели <b><I>b1</i></b> и <b><I>b2</i></b> на начало соответствующих буферов (блок 4) и в цикле (блоки 5 - 15) перебираем символы входного буфера, доки не встретим признак конца строки (блок 5). 
<p>&nbsp;&nbsp;&nbsp;&nbsp;В каждой итерации цикла мы переписываем один символ из входного буфера в выходной (блок 6) и сдвигаем указатели в буферах (блок 7). Потом проверяем - не был ли только что переписанный символ пробелом (блок 8). Если так, то в цикле (блоки 9 - 11) записываем в выходной буфер <b><I>nb</i></b> пробелов. После обработки каждого промежутка уменьшаем счетчик слов (блок 12) и, если еще есть промежутки (блок 13), перевычисляем <b><I>nb</i></b> (блок 14). 
После выхода из цикла в выходной буфер дописывается еще символ конца строки (блок 16).
<p>&nbsp;&nbsp;&nbsp;&nbsp;Обратите внимание на то, что те переменные, которые используются для вычисления <b><I>nb</i></b>, уменьшаются на 1 при обработке каждого следующего символа: при обработке символа из входного буфера уменьшаются и <b><I>l</i></b>, и <b><I>lm</i></b> (блок 15), а при дописывании каждого пробела в выходной буфер - только <b><I>lm</i></b> (блок 11).

<h4 align=center>5.2. Определение переменных программы </h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Символьная строка, в которой сохраняется имя файла, который мы обрабатываем:
<pre>
    char filename[80];  
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Два буфера для сохранения входной и выходной строк, одни те же буферы используются на первой и на второй фазе. Размер обоих буферов - 81 символ (80 символов - ограничение, которое допускается условиями задания, + 1 символ - признак конца строки).
<pre>
    char bu1[81], bu2[81];
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Символьные строки, как данные большого объема, должны размещаться в статической памяти. Остальные переменные - локальные в функции <b><I>main()</i></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Для реализации алгоритма нам прежде всего будут нужны файловые переменные - для входного и выходного файлов. Мы будем пользоваться функциями форматного ввода-вывода, которые требуют объявления файлов як переменных типа <b><I>FILE*</i></b>:
<pre>
    FILE *inf, *outf;
</pre>
&nbsp;&nbsp;&nbsp;&nbsp;Эти две программные переменные используются и в первой, и во второй фазе программы, хотя в разных фазах они ассоциируются с разными физическими файлами.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Работа с символьными строками будет вестись через указатели, следовательно, нужны будут указатели на текущие символы во входной и выходной строке соответственно:
<pre>
    char *b1, *b2; 
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;В соответствии с алгоритмом нам нужна переменная для хранения предыдущего символа:
<pre>
    char os;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Переменные для хранения: текущей длины строки, максимальной длины строки, максимальной длины строки с модификацией ее (см. алгоритм 2-ой фазы):
<pre>
    int  l; int lmax; int lm;       
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Переменные для хранения: количества слов и количества дополнительных пробелов между словами:
<pre>
    int  nw; int nb;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Всем целочисленным переменным мы даем тип <b><I>int</i></b> из соображений стилевой традиции, хотя объективно хватило бы и типа <b><I>short</i></b>. 

<h4 align=center>5.3. Разработка текста программы </h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Мы позволим себе несколько сократить описание текста программы, ибо в основном он однозначно отражает приведенные выше алгоритмы и описания данных. Сосредоточимся только на особенностях реализации.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Файлы, которые включаются в программу:
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b><I>&lt;stdio.h&gt;</i></b> - описания функций форматного ввода-вывода;
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b><I>&lt;string.h&gt;</i></b> - описания строковых функций (<b><I>strlen()</i></b>,<b><I>string()</i></b>);
<p>&nbsp;&nbsp;&nbsp;&nbsp;<b><I>&lt;stdlib.h&gt;</i></b> - описания функций общего назначения (<b><I>exit()</i></b>,<b><I>atoi()</i></b>).
<p>&nbsp;&nbsp;&nbsp;&nbsp;Функция <b><I>main()</i></b> имеет два параметра, это форматный состав параметров, которые передаются главной функции: второй параметр - массив указателей на символьные строки, первый - количество элементов в этом массиве. Элемент с индексом 0 - строка обращения к программе, а тот параметр, которого требуют спецификации (имя файла) - элемент с индексом 1. Проверка параметров состоит в проверке их количества.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Для открытия файлов повсюду в программе используется функция <b><I>fopen()</i></b>, она возвращает указатель, который является файловой переменной в программе. Мы всегда проверяем этот указатель; если он пустой, мы выдаем на экран сообщение про невозможность открытия файла и завершаем программу с помощью функции <b><I>exit()</i></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Заголовок цикла:
<pre>
    for (lmax=0; fgets(bu1,80,inf)!=NULL; ) {
</pre>
реализует сразу блоки 4, 5, 6 схемы алгоритма рис.2. Для чтения строки мы применяем функцию <b><I>fgets()</i></b>, которая считывает строку из файла. При попытке читать за концом файла эта функция возвращает <b><I>NULL</i></b>, что и есть признаком конца файла.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Следующий сложный заголовок цикла:
<pre>
    for (os=' ',nw=0,b1=bu1, b2=bu2; *b1; os=*b1++) {
</pre>
реализует блоки 2,3,4,5,10 схемы алгоритма рис.3.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Оператор:
<pre>
    switch (*b1) { . . . }
</pre>
- разветвление в зависимости от значения текущего символа. Обратите внимание на то, как реализована та часть разветвления, которая на схеме рис.3 представлена блоком 6, в программе это:
<pre>
    case ' ': if (os==' ') break;
</pre>
- если предыдущий символ - пробел, происходит выход из <b><I>switch</i></b>, если же нет - управление переходит на следующий оператор, т.е., на обработку остальных символов.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Сложное условие исключения пробелов в конце строки (блоки 11 - 14 рис.3) в программе реализовано одним оператором <b><I>if - else</i></b>:
<pre>
    if ((b2&gt;=bu2)&&(*(b2-1)==' ')) *(b2-1)=0;
    else *b2=0;
</pre>
Вывод промежуточного результата выполняется оператором:
<pre>
    fprintf(outf,"%02d %s\n",nw,bu2);
</pre>
&nbsp;&nbsp;&nbsp;&nbsp;Этот оператор выводит текстовую строку, в которой два первые символы - цифры количества слов в строке, далее через пробел - сама строка.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Цикл чтения строк на второй фазе:
<pre>
    while (fgets(bu1,80,inf)!=NULL) {
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Необходимо пояснить разделение прочитанной строки на количество слов и саму строку. Мы записываем признак конца строки в элемент с индексом 2:
<pre>
    bu1[2]=0; 
</pre>
таким образом мы разбиваем строку на две строки. Первая из этих строк - два первых символа, мы преобразуем их в число слов:
<pre>
    nw=atoi(bu1);
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Указатель <b><I>b1</i></b> мы устанавливаем на элемент с индексом 3, т.е., на начало самих данных строки:
<pre>
    b1=bu1+3;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Потом мы еще определяем длину строки и записываем признак конца вместо последнего символа строки - символа перехода на новую строку:
<pre>
    l=strlen(b1)-1; b1[l]=0;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Поскольку в формуле вычисления <b><I>nb</I></b> мы используем <b><I>nw-1</I></b>, мы сразу уменьшаем <b><I>nw</I></b> на 1 и далее сравниваем его з 0: 
<pre>
    if (--nw&gt;0) {
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Сложный заголовок цикла:
<pre>
    for (lm=lmax, b2=bu2; *b1; l--,lm--) {
</pre>
реализует блоки 3,4,5,15 схемы алгоритма рис.4.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Оператор:
<pre>
    if ((*b2++=*b1++)==' ') {
</pre>
реализует блоки 6, 7, 8 схемы алгоритма рис.4: пересылка, наращивание указателей, анализ пересланного символа.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Вывод результатов в файл выполняется функцией <b><I>fprintf()</i></b>, но для обработанной строки параметр функции - <b><I>b2</i></b> - указатель на выходной буфер, а для необработанной - на входной - <b><I>b1</i></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Уничтожение временного файла выполняется функцией <b><I>unlink()</i></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Полный текст программы приведен ниже.

<pre>
/***************************************************/
/*              Лабораторная работа ╧15            */
/*             Обработка текстового файла          */
/*         Пример выполнения. Вариант ╧30.         */
/***************************************************/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char filename[80];     /* имя файла */
char bu1[81], bu2[81]; /* входной и выходной буферы */

int main(int an, char *av[]) {
 char *b1, *b2; /* текущие указатели в буферах */
 char os;       /* предыдущий символ */
 FILE *inf, *outf;  /* файловые переменные */
 int  l,        /* текущая длина строки */
      lmax,     /* максимальная длина строки */
      lm;       /* макс. длина строки (рабочая) */
 int  nw,       /* количество слов */
      nb;       /* количество пробелов */

  /* проверка параметров */
  if (an&lt;2) {
    printf("Не задан параметр вызова\n");
    exit(0);
    }
  strcpy(filename,av[1]);
  /* открытие файлов */
  if ((inf=fopen(filename,"r"))==NULL) {
    printf("Невозможно открыть файл: %s\n",filename);
    exit(0);
    }
  if ((outf=fopen("TMP","w"))==NULL) {
    printf("Невозможно создать файл: TMP\n");
    exit(0);
    }
  /* первая фаза - определение максимальной длины */
  /* чтение фала строка за строкой */
  for (lmax=0; fgets(bu1,80,inf)!=NULL; ) {
    /* удаление из строки лишних пробелов 
       и определение количества слов */
    for (os=' ',nw=0,b1=bu1, b2=bu2; *b1; os=*b1++) {
      switch(*b1) {
        case 0xA: /* символ новой строки удаляется */
          break;
        case ' ': /*2-й пробел подряд удаляется */
          if (os==' ') break;
        default: /* остальные символы переписываются */
          if (os==' ') nw++; /* начало слова */
          *b2++=*b1;
          break;
          }
        }
    /* удаление пробела в конце */
    if ((b2&gt;=bu2)&&(*(b2-1)==' ')) *(b2-1)=0;
    else *b2=0;
    /* вывод в файл количества слов и строки */
    fprintf(outf,"%02d %s\n",nw,bu2);
    /* определение максимальной длины */
    l=strlen(bu2);
    if (l&gt;lmax)lmax=l;
    }
  fclose(inf);
  fclose(outf);

  /* вторая фаза - окончательная обработка */
  /* открытие файлов */
  if ((inf=fopen("TMP","r"))==NULL) {
    printf("Невозможно открыть файл: TMP\n");
    exit(0);
    }
  if ((outf=fopen(filename,"w"))==NULL) {
    printf("Невозможно открыть файл: %s\n",filename);
    exit(0);
    }
  /* чтение фала строка за строкой */
  while (fgets(bu1,80,inf)!=NULL) {
    /* виделение количества слов и текста */
    bu1[2]=0; nw=atoi(bu1);
    b1=bu1+3;
    l=strlen(b1)-1; b1[l]=0;
    /* если слов 1 или 0 - строка остается как есть  */
    if (--nw&gt;0) {
      /* определение количества пробелов между словами */
      nb=(lmax-l)/nw;
      for (lm=lmax, b2=bu2; *b1; l--,lm--) {
        /* перезапись символов на выход */
        if ((*b2++=*b1++)==' ') {
          /* если конец слова - добавить пробели */
          for (; nb; nb--) { lm--; *b2++=' ';}
          /* коррекция количества пробелов между словами */
          if (--nw) nb=(lm-l)/nw;
          }
        }
      /* признак конца строки в выходном буфере */
      *b2=0;
      /* вывод в файл */
      fprintf(outf,"%s\n",bu2);
      }
    /* вывод строки, которая осталась без изменений */
    else fprintf(outf,"%s\n",b1);
    }
  fclose(inf);
  fclose(outf);
  /* уничтожение промежуточного файла */
  unlink("TMP");

  return 0;
}
</pre>


<h4 align=center>5.5. Отладка программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Для отладки программы прежде всего следует подготовить текст, который будет использоваться как входные данные контрольного примера. В этом тексте должны быть такие строки, которые позволяют проверить разные ветви алгоритма программы, а именно:
<ul>
<li>строки, в которых между некоторыми словами есть промежутки в два и более пробелов;
<li>строки, в которых есть пробелы в начале строки;
<li>строки, в которых есть пробелы в конце строки;
<li>строки, которые состоят из одного слова;
<li>строки, которые состоят из одного слова с пробелами перед ним и после него;
<li>строки, которые состоят из одних пробелов;
<li>пустые строки.
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Обязательно следует проверить также работу программу при отсутствии входных параметров и при задании имени несуществующего файла.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Поскольку программа изменяет файл, рекомендуем на этапе отладки записывать результат не в той же файл, а в другой. Тогда подготовленный файл с данными контрольного примера можно буде использовать много раз. Рекомендуем также при отладке удалить из программы оператор уничтожения промежуточного файла - это дает возможность контролировать промежуточные результаты.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Отладку самого преобразования строк можно вести в пошаговом режиме с отслеживанием содержимого входного и выходного буферов и значений ключевых переменных.

<h4 align=center>5.6. Результаты работы программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Ниже приведен пример результатов работы программы, текст, использованные для этого примера, удовлетворяет требованиям, приведенным в предыдущем пункте.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Входной файл:
<pre>
Первая часть цикла лабораторных работ по курсу 
"Основы программирования               
      и алгоритмические языки" посвящена языку C в его 
базовом варианте, 
изложенном в классической работе [1].

Для 
выполнения  этой    части      цикла            годится
  любая операционная среда 
и любая система программирования C, так как         
     те 
свойства языка, которые   тут изучаются, являются ядром языка 
и присутствуют во всех его   реализациях. В частности,  мы
        внедряем
этот цикл  в среде операционной системы PC DOS
 7.0 и системы программирования Borland  C++     3.1.
     
Лабораторная  
       работа
 1 ориентирована на выбранную систему программирования, 
        ее           цель                        - 
сформировать у студентов начальные навыки 
подготовки, выполнения       
и отладки программ в выбранной среде. Остальные
работ от 
среды не зависят.
</pre>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Выходной файл:

<pre>
Первая   часть   цикла   лабораторных   работ   по    курсу 
"Основы                                    программирования
и  алгоритмические  языки"  посвящена   языку   C   в   его
базовом                                           варианте,
изложенном      в      классической       работе       [1].
Для
выполнения       этой       части       цикла       годится
любая                  операционная                   среда
и   любая   система    программирования    C,    так    как
те
свойства языка, которые тут изучаются, являются ядром языка
и присутствуют во всех его  реализациях.  В  частности,  мы
внедряем
этот   цикл   в   среде   операционной   системы   PC   DOS
7.0   и   системы   программирования   Borland   C++   3.1.

Лабораторная
работа
1  ориентирована  на  выбранную  систему  программирования,
ее                          цель                          -
сформировать     у     студентов      начальные      навыки
подготовки,                                      выполнения
и   отладки   программ   в   выбранной   среде.   Остальные
работы                                                   от
среды                      не                      зависят.
</pre>
<h4 align=center>5.7. Выводы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;При выполнении лабораторной работы изучены вопросы:
<ul>
<li>функции файлового ввода-вывода
<li>передача параметров главной функции
<li>символьные строки и указатели
</ul>

<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l14.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l16.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>
