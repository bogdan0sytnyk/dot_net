<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, C">

<title>Основы программирования. Лабораторные работы </title>
<!--                                                                   -->
<!-- (C) Owner: Alexander S. Derevjanko -->
<!-- (C) ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l12.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l14.html>Вперед</a></td></tr>
</table>
</p>
<hr>
<h2 align=center>Лабораторная работа ╧13</h2>

<h2 align=center>Функции пользователя</h2>

<h3 align=center>1. Цель работы</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Целью лабораторной работы является получение практических навыков в работе с функциями пользователя и передачей параметров функциям.

<h3 align=center>2. Темы для предварительной проработки </h3>
<ul>
<li>Указатели и массивы.
<li>Функции пользователя.
</ul>

<h3 align=center>3. Задания для выполнения</h3>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Составить программу, которая решает задачу для лабораторной работы ╧9 с такими дополнительными условиями:
<ul>
<li>размерность матрицы должна вводиться при выполнении программы;
<li>само решение задачи должно быть оформлено в виде функции, которой передается матрица и ее размерность.
</ul>
<h3 align=center>4. Варианты индивидуальных заданий</h3>

<p><table align=center>
<tr><td>&nbsp;<a href=v09_01.html>1</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_02.html>2</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_03.html>3</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_04.html>4</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_05.html>5</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_06.html>6</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_07.html>7</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_08.html>8</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_09.html>9</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_10.html>10</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v09_11.html>11</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_12.html>12</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_13.html>13</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_14.html>14</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_15.html>15</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_16.html>16</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_17.html>17</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_18.html>18</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_19.html>19</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_20.html>20</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v09_21.html>21</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_22.html>22</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_23.html>23</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_24.html>24</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_25.html>25</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_26.html>26</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_27.html>27</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_28.html>28</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_29.html>29</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_30.html>30</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table>
</p>

<h3 align=center>5. Пример решения задачи (вариант 30)</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Решение приводится со ссылками на 
<a href=l09.html>работу ╧9</a>.

<h4 align=center>5.1. Разработка алгоритма решения.</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Сам алгоритм решения мог бы быть тем же, что и в  работе ╧9. Но обратим внимание на то, что условие этой работы несколько отлично от условия работы ╧9. Если в работе ╧9 мы имели фиксированную размерность матрицы, то тут у нас размерность матрицы заранее не известна. Составляет ли это существенное различие? Да. Если мы проверим функционирования алгоритма работы ╧9 при разных значениях размерности (<b><i>S</I></b>), то мы убедимся, что корректно он срабатывает только при нечетных значениях <b><i>S</I></b>. При четных значениях верхняя половина матрицы формируется правильно, а в нижней половине область ненулевых значений будет захватывать также и сами диагонали, что не соответствует условиям задания. Поэтому для этой работы следует пересмотреть алгоритм.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Для элемента, который лежит на главной диагонали, индексы удовлетворяют условию: <b><i>L=R</I></b>, на побочной - <b><i>R=S-L-1</I></b>. Следовательно, для верхней половины условие попадания в ненулевую область: <b><i>L &lt; R &lt; S-L-1</I></b>, а для нижней: <b><i>S-L-1 &lt; R &lt; L</I></b>. Или, обобщая: <b><i>min(L,S-L-1) &lt; R &lt; max(L,S-L-1) </I></b>. В схеме алгоритма, которая приведена на рисунке 1, мы используем именно это условие. К тому же в схеме отражено разделение программы на две функции: главную функцию - <b><i>main()</I></b>, которая выполняет выделения памяти для матрицы, вызов функции заполнения матрицы и вывод результата, и функцию <b><i>fill()</I></b>, которая выполняет заполнение матрицы по заданным правилам.

<p><table align=center border><tr><td><img src=l13_e001.gif></td></tr><td>
Рисунок 1. Схема алгоритма</td></tr></table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;В этой работе ми несколько усложним алгоритм, добавив в него проверку значения <b><I>S</I></b>, которое введено оператором (блоки 3 - 8). Нижняя граница для значения <b><I>S - 1</I></b>, поскольку матрица нулевой или отрицательной размерности просто не имеет смысла. Верхняя граница - 24, поскольку для матрицы большего размера невозможно будет обеспечить наглядный вывод (она не поместится на экране).
<h4 align=center>5.2. Представление матрицы в памяти</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Если в работе ╧9 было возможно представлять матрицу в программе как двумерный массив - естественное представление матрицы, то при условии динамического размещения в памяти ее представление уже не такое простое. Возможны три варианта размещения в памяти и представления матрицы в программе. Во всех трех вариантах очевидно, что общий объем памяти для размещения данных матрицы должен быть <b><I>S<sup>2</sup></I></b> элементов типа <b><i>int</I></b>.

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>Вариант 1</b> показан на рис.2

<p><table align=center border><tr><td><img src=l13_e002.gif></td></tr><td>
Рисунок 2. Размещение в памяти. Вариант 1.</td></tr></table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Для данных матрицы выделяется необходимый объем памяти. В программе объявляется указатель на начало этой области. Тип этого указателя - <b><i>int*</I></b>. Таким образом, матрица является одномерным массивом и для того, чтобы по номеру строки (<b><i>L</I></b>) и столбца (<b><i>R</I></b>) определить индекс в одномерном массиве (<b><i>N</I></b>) следует выполнить вычисление: <b><i>N=L*S+R</I></b>.

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>Вариант 2</b> показан на рис.3.

<p><table align=center border><tr><td><img src=l13_e003.gif></td></tr><td>
Рисунок 3. Размещение в памяти. Вариант 2.</td></tr></table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Память для данных матрицы выделяется так же, как и в предыдущем случае. Но дополнительно выделяется память для одномерного массива размерности <b><I>S</I></b>, элементы которого имеют тип <b><i>int*</I></b> (указатель на целое). Указатель на начало этого массива имеет тип <b><i>int**</I></b> (указатель на указатель на целое). В элементы этого массива записываются указатели на начала соответствующих строк в массиве данных матрицы. В этом варианте можно обращаться к данным матрицы, указывая номера строки и столбца как два индекса в массиве указателей.

<p>&nbsp;&nbsp;&nbsp;&nbsp;<b>Вариант 3</b> показан на рис.4.
 
<p><table align=center border><tr><td><img src=l13_e004.gif></td></tr><td>
Рисунок 4. Размещение в памяти. Вариант 3</td><tr></table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Этот вариант отличается от предыдущего тем, что для каждой строки матрицы память выделяется отдельно (<b><i>S</I></b> областей памяти по <b><i>S</I></b> элементов в каждой), и в массив указателей заносятся указатели на соответствующие области. Таким образом, матрица необязательно занимает смежные области памяти. Можно обращаться к данным матрицы, указывая два индекса. Выделение памяти (и соответственно - освобождение) нужно выполнять в цикле.
Вариант 1 обеспечивает экономию памяти, а варианты 2 и 3 - возможность "естественного" обращения к элементам матрицы. Вариант 3 позволяет рациональнее использовать память, чем вариант 2, но вариант 2 алгоритмически более простой. Мы покажем реализации алгоритма для вариантов 1 и 3.

<h4 align=center>5.3. Определение переменных программы (вариант 1)</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Программа будет состоять из двух функций - <b><i>main()</I></b> и <b><i>fill()</I></b>. В соответствии с принципом модульности желательно, чтобы функции имели минимальное количество общих переменных, и здесь мы имеем возможность обойтись совсем без них. Все переменные, с которыми работают наши функции, будут локальными переменными функций или параметрами.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Переменные для функции <b><i>main()</I></b>. 
<p>&nbsp;&nbsp;&nbsp;&nbsp;Указатель на начало линейного массива, в котором размещаются данные матрицы:
<pre>
    int *Ar;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Размерность массива:
<pre>
    int S;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Общее количество элементов массива (его использование будет видно из текста программы):
<pre>
    int size;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Указатель на текущий элемент массива при его выводе:
<pre>
    int *Cr;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Счетчик выведенных элементов:
<pre>
    int i;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Параметры для функции <b><I>fill()</I></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Указатель на начало линейного массива, в котором размещаются данные матрицы:
<pre>
    int *A;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Размерность массива:
<pre>
    int s;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Переменные для функции <b><I>fill()</I></b>. 
<p>&nbsp;&nbsp;&nbsp;&nbsp;Указатель на текущий элемент массива при его обработке:
<pre>
    int *C;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Номера строки и столбца: 
<pre>
    short l, r;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Текущий член линейной последовательности:
<pre>
    int k=1;
</pre>


<h4 align=center>5.4. Разработка текста программы (вариант 1)</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Текст программы начинаем с включения файлов: <b><i>stdio.h</I></b>, <b><i>alloc.h</I></b>, <b><i>stdlib.h</I></b> (в последнем определены макросы <b><i>max</I></b> и <b><i>min</I></b>).
<p>&nbsp;&nbsp;&nbsp;&nbsp;Включаем описание функции <b><i>fill()</I></b> и открываем главную функцию. В главной функции объявляем ее локальные переменные, выводим приглашение и вводим значение размерности матрицы <b><i>S</I></b>. Размерность сравнивается с нижней и с верхней границей и, если она выходит за границы, выводится соответствующее сообщение и программа завершается (функцией <b><i>exit()</I></b>). Если <b><i>S</I></b> удовлетворяет установленным условиям, его значение выводится на экран.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Потом выделяется память для размещения матрицы. Для этого вызывается функция <b><i>malloc()</I></b>. Ей передается размер памяти в байтах, который нужен для размещения <b><i>S<sup>2</sup></I></b> элементов типа <b><i>int</I></b>. Функция <b><i>malloc()</I></b> возвращает указатель на выделенную область памяти, значение этого указателя записывается в переменную <b><i>Ar</I></b> - это будет указатель на начало массива, в котором разместятся данные матрицы. Если значение, которое вернула функция <b><i>malloc()</I></b>, - пустой указатель, это признак того, что памяти не хватает, в этом случае видается сообщение и программа завершается.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Оператор:
<pre>
    fill(Ar,S);
</pre>
- обращение к функции заполнения матрицы. Функции передаются: указатель на начало массива и размерность матрицы.
<p>&nbsp;&nbsp;&nbsp;&nbsp;После возврата управления из функции <b><i>fill()</I></b> уже готовая матрица выводится на экран. При выводе матрица рассматривается как линейный массив из <b><i>S<sup>2</sup></I></b> элементов. Счетчик <b><i>i</I></b> меняется от <b><i>0</I></b> до <b><i>S2-1</I></b>. Но обращение к элементам матрицы в этом цикле ведется через указатель <b><i>Cr</I></b>. В начальных установках этот указатель устанавливается на начало массива, а после каждой итерации увеличивается на 1, т.е. сдвигается на следующий элемент массива. Счетчик <b><i>i</I></b> используется для определения момента выхода из цикла, а также для перехода на новую строку экрана после вывода каждых <b><i>S</I></b> элементов - для этого проверяется условие: <b><i>i%S==S-1</I></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Последним действием в функции <b><i>main()</I></b> является освобождение с помощью функции <b><i>free()</I></b> выделенной ранее памяти.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Функция <b><i>fill()</I></b> получает параметры - указатель на начало массива и размерность матрицы. Тело функции начинается с объявления ее локальных переменных, переменная <b><i>k</I></b> получает начальное значение при объявлении. 
<p>&nbsp;&nbsp;&nbsp;&nbsp;Далее в функции организуются вложенные циклы для перебора строк и столбцов. Но номера строки и столбца используются не для обращения к элементам матрицы, а только для проверки, попадает ли элемент в нулевую или ненулевую область (в точном соответствии условиям, приведенным в п.5.2). Обращение к элементам матрицы ведется через указатель <b><i>C</I></b>, который указывает на текущий элемент матрицы. Этот указатель устанавливается на начало массива в начальных установках внешнего цикла и увеличивается на 1 в конце каждой итерации внутреннего цикла.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Полный текст программы приведен ниже.

<pre>
/***************************************************/
/*              Лабораторная работа ╧13            */
/*                      Функции                    */
/*          Пример выполнения. Вариант ╧30.        */
/*                Вариант реализации 1             */
/***************************************************/
#include &lt;stdio.h&gt;
#include &lt;alloc.h&gt;
#include &lt;stdlib.h&gt;
void fill(int *, int);

/*** главная функция ***/
main() {
 int *Ar, /* указатель на начало массива */
     *Cr; /* текущий указатель у массиве */
 int i,   /* счетчик элементов */
     S;   /* размерность матрицы */

  /* ввод размерности */
  printf("Введите размерность матрицы &gt;");
  scanf("%d",&S);
  /* проверка размерности */
  if (S&lt;=0) {
    printf("Размерность слишком мала\n");
    exit(0);
    }
  if (S&gt;24) {
    printf("Размерность слишком велика\n");
    exit(0);
    }
  printf("S=%d\n",S);
  /* выделение памяти */
  if ((Ar=(int *)malloc(sizeof(int)*S*S))==NULL) {
    printf("Недостаток памяти\n");
    exit(0);
    }
  /* обращение к функции заполнения матрицы */
  fill(Ar,S);
  /* вывод матрицы */
  for (Cr=Ar, i=0; i&lt;S*S; Cr++,i++) {
      printf("%3d",*Cr);
      if (i%S==S-1) putchar('\n');
      }
  /* освобождение памяти */
  free(Ar);
  return 0;
}
/*** функция заполнения матрицы ***/
/* параметры: A - указатель на начало массива
              s - размерность матрицы */
void fill(int *A, int s) {
 int *C;      /* текущий указатель в массиве */
 short l, r;  /* строка и столбец */
 int k=1;     /* текущий член ЛП */
  for (l=0,C=A; l&lt;s; l++)     /* перебор строк */
    for (r=0; r&lt;s; r++, C++)  /* перебор столбцов */
      /* условие нулевого значения */
      if ((r&gt;=max(l,s-l-1))||(r&lt;=min(l,s-l-1))) *C=0;
      else *C=k++;
      /* конец перебора строк */
    /* конец перебора столбцов */
}
</pre>

<h4 align=center>5.5. Отличия для варианта реализации 3</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;В тексте программы для варианта реализации 3 мы для упрощения исключили все проверки корректности. Описание реализации мы ограничиваем только отличиями от варианта 1.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Указатель <b><i>Ar</I></b> в функции <b><i>main()</I></b> тут - указатель на массив указателей, следовательно, его тип - <b><i>int**</I></b>. Выделение памяти ведется в несколько приемов: сначала выделяется память для массива из <b><i>S</i></b> указателей, а потом в цикле - <b><i>S</I></b> раз выделяется память для массива из <b><i>S</i></b> целых чисел, адреса выделенных массивов записываются в элементы массива указателей. При выводе матрицы используются <b><i>i</I></b> и <b><i>j</I></b> - номера строки и столбца и обращение к элементам матрицы ведется как к элементам 2-мерного массива.
<p>&nbsp;&nbsp;&nbsp;&nbsp;Первый параметр функции <b><i>fill()</I></b> - указатель на указатель на <b><i>int</I></b>. Это дает возможность использовать номера строки и столбца - <b><i>l</I></b> и <b><i>r</I></b> также и для обращения к элементам матрицы.

<pre>
/***************************************************/
/*              Лабораторная работа ╧13            */
/*                      Функции                    */
/*          Пример выполнения. Вариант ╧30.        */
/*                Вариант реализации 2             */
/***************************************************/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;alloc.h&gt;
void fill(int far **, int);

/*** главная функция ***/
main() {
 int far **Ar; /* указатель на массив указателей */
 int i, j; /* строка и столбец */
 int S;    /* размерность матрицы */
  /* ввод размерности */
  printf("Enter S&gt;"); scanf("%d",&S); 
  printf("S=%d\n",S);
  /* выделение памяти для массива указателей */
  Ar=(int far **)malloc(sizeof(int *)*S);
  /* выделение памяти для каждой строки 
     и заполнение массива указателей */
  for (i=0; i&lt;S; i++) 
    Ar[i]=(int far *)malloc(sizeof(int)*S);
  /* обращение к функции заполнения матрицы */
  fill(Ar,S);
  /* вывод матрицы */
  for (i=0; i&lt;S; i++) {
    for (j=0; j&lt;S; printf("%3d",Ar[i][j++]) );
    putchar('\n');
    }
  /* освобождение памяти строк */
  for ( i=0; i&lt;S; free(Ar[i++]) );
  /* освобождение памяти массива указателей */
  free(Ar);
  return 0;
}
/*** функция заполнения матрицы ***/
/* параметры: A - указатель на массив указателей
              s - размерность матрицы */
void fill(int far **A, int s) {
 short l, r; /* строка и столбец */
 short k=1;  /* текущий член ЛП */
  for (l=0; l&lt;s; l++)    /* перебор строк */
    for (r=0; r&lt;s; r++)  /* перебор столбцов */
      /* условие нулевого значения */
      if ((r&gt;=max(l,s-l-1))||(r&lt;=min(l,s-l-1))) 
        A[l][r]=0;
      else A[l][r]=k++;
      /* конец перебору строк */
    /* конец перебору столбцов */
}
</pre>


<h4 align=center>5.6. Отладка программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;При отладке программы срабатывают те же соображения, которые высказаны к работе ╧9: рекомендуется вести поиск ошибок на основе анализа выведенных программой данных, но при желании можно использовать и пошаговый режим.

<h4 align=center>5.5. Результаты работы программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Ниже приведены два примера результатов работы программы: для четного и нечетного значений размерности.

<pre>
S=10
  0  1  2  3  4  5  6  7  8  0
  0  0  9 10 11 12 13 14  0  0
  0  0  0 15 16 17 18  0  0  0
  0  0  0  0 19 20  0  0  0  0
  0  0  0  0  0  0  0  0  0  0
  0  0  0  0  0  0  0  0  0  0
  0  0  0  0 21 22  0  0  0  0
  0  0  0 23 24 25 26  0  0  0
  0  0 27 28 29 30 31 32  0  0
  0 33 34 35 36 37 38 39 40  0

S=9
  0  1  2  3  4  5  6  7  0
  0  0  8  9 10 11 12  0  0
  0  0  0 13 14 15  0  0  0
  0  0  0  0 16  0  0  0  0
  0  0  0  0  0  0  0  0  0
  0  0  0  0 17  0  0  0  0
  0  0  0 18 19 20  0  0  0
  0  0 21 22 23 24 25  0  0
  0 26 27 28 29 30 31 32  0
</pre>


<h4 align=center>5.6. Выводы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;При выполнении лабораторной работы изучены вопросы:
<ul>
<li>функции пользователя
<li>передача параметров функции
<li>2-мерные массивы и указатели
</ul>

<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l12.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l14.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>
