<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, C">

<title>Основы программирования. Лабораторные работы </title>
<!--                                                                   -->
<!-- (C) Owner: Alexander S. Derevjanko -->
<!-- (C) ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l11.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l13.html>Вперед</a></td></tr>
</table>
</p>
<hr>
<h2 align=center>Лабораторная работа ╧12</h2>

<h2 align=center>Указатели, символьные строки и функции</h2>

<h3 align=center>1. Цель работы</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Целью лабораторной работы является совершенствование практических навыков в работе с указателями и получение навыков в работе с функциями пользователя.

<h3 align=center>2. Теми для предварительной проработки </h3>
<ul>
<li>Указатели. Типизированные указатели.
<li>Указатели та массивы.
<li>Функции пользователя
</ul>

<h3 align=center>3. Задания для выполнения </h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разработать функцию, которая выполняет ту обработку символьной строки, которая определена в Вашем индивидуальном задании. При реализации функции запрещается пользоваться функциями библиотек языка C.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Примечания:<ol>
<li>В большинстве заданий необходимо предусмотреть работу функции при некорректном задании ее параметров.
<li>В тех заданиях, где применен термин "слово", под ним понимается любая последовательность символов, ограниченная любым числом пробелов и/или началом/концом строки.
 </ol>


<h3 align=center>4. Варианты индивидуальных заданий</h3>
<p><table align=center>
<tr><td>&nbsp;<a href=v12_01.html>1</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v12_02.html>2</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v12_03.html>3</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v12_04.html>4</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v12_05.html>5</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v12_06.html>6</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v12_07.html>7</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v12_08.html>8</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v12_09.html>9</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_10.html>10</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v12_11.html>11</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_12.html>12</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_13.html>13</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_14.html>14</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_15.html>15</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_16.html>16</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_17.html>17</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_18.html>18</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_19.html>19</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_20.html>20</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v12_21.html>21</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_22.html>22</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_23.html>23</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_24.html>24</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_25.html>25</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_26.html>26</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_27.html>27</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_28.html>28</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_29.html>29</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v12_30.html>30</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table>
</p>

<h3 align=center>5. Пример решения задачи (вариант 30)</h3>

<h4 align=center>5.1. Разработка спецификаций функции.</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Дадим функции, которую мы создаем, имя <b><I>substr()</i></b>. Состав и типы ее параметров достаточно просто могут быть определены из задания: это должны быть строка-источник данных (<b><I>src</i></b>), строка-результат (<b><I>dest</i></b>), начальная позиция (<b><I>pos</i></b>) и длина результата (<b><I>len</i></b>).
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Строки должны быть определены в той функции, которая вызывает нашу, следовательно, функции <b><I>substr()</i></b> передаются указатели на эти строки. Остальные параметры должны быть целыми числами.
Обратите внимание на наши соображения по поводу размещения символьных строк. Вполне понятно, что память для строки-источника должна быть выделена во внешней функции. Но то же самое мы предусматриваем и для строки-результата - почему? Если мы объявим строку-результат как локальную в функции <b><I>substr()</i></b>, то память для нее будет выделена в нашей функции, и эта память будет освобождена, когда выполнение функции закончится, следовательно, та функция, которая вызвала нашу, воспользоваться результатом не сможет. Если же мы выделим память в нашей функции явным образом (с помощью <b><I>malloc()</i></b>), то память сохранится, но тогда на ту функцию, которая вызвала нашу, возлагается обязанность явным образом освободить эту память, когда строка-результат уже не будет нужна. 
Проанализируем возможности некорректного задания параметров при вызове функции.
Во-первых, параметры <b><I>pos</i></b> и <b><I>len</i></b> не могут иметь отрицательного значения - оно просто не имеет смысла. Во-вторых, возможно такое значение параметра <b><I>pos</i></b>, которое будет превышать длину строки-источника. Будем считать все эти случаи ошибочным заданием параметров. Что должна делать функция при ошибочном задании параметров? Можно предложить три варианта:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. Функция аварийно завершает работу всей программы.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. Функция никак не реагирует на ошибку.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. Функция возвращает какой-то признак ошибки.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Из этих вариантов мы выбираем третий, исходя из тех соображений, что функция может использоваться в большом числе программ, так что пусть внешняя программа, получив признак ошибки, сама принимает решение о дальнейших действиях при ошибке. А если так, то наша функция должна возвращать признак ошибки. Удобно сделать этот признак именно тем значением, которое функция возвращает. 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Установим, что это значение будет 0 при нормальной работе функции, а при ошибке в параметрах это значение будет -1, а строка-результат будет пустой.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возможен еще один вариант некорректного задания параметров - когда начало подстроки лежит в пределах строки-источника, а конец выходит за ее конец. Договоримся не считать этот случай фатальной ошибкою, пусть в этом случае функция формирует результат меньшей длины, чем задано и возвращает 1.

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Еще одна проблема: если память для результата выделяет внешняя функция, что делать, если длина результата будет больше объема выделенной памяти? Чтобы контролировать эту ситуацию нужно ввести еще один параметр функции - максимальную длину строки-результата, а это нежелательно. Примем решение не контролировать такую ситуацию, перекладывая ответственность за нее на ту функцию, которая вызывает нашу. Это решения базируется на том, что именно так поступают и библиотечные функции языка С.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В итоге разработки спецификации для функции мы формулируем такое описание функции substr():
<pre>
    int substr(
      char *src,
      char *dest,
      int pos,
      int len);
</pre>

<h4 align=center>5.2. Разработка алгоритма решения.</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Мы разрабатываем алгоритм только для функции <b><I>substr()</i></b>, игнорируя внешнюю функцию, которая вызывает ее.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При разработке алгоритма мы сразу же "заглядываем вперед", имея в виду его последующую реализацию в программном коде, т.к. уже в задании обусловлены некоторые детали реализации. 
<p><table align=center border>
<tr><td><img src=l12_1.gif></td></tr></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Функция начинается с цикла (блоки 2 -5), цель которого - установить указатель на символ с номером <b><I>pos</i></b>. Как параметр цикла используется параметр функции <b><I>pos</i></b>, который "работает на уменьшение". В каждой итерации цикла <b><I>pos</i></b> уменьшается на 1 (блок 5), а указатель <b><I>src</i></b> увеличивается на 1 (блок 4). Когда <b><I>pos</i></b> уменьшится до 0 (блок 3) - указатель должен быть установлен на нужный символ. Но есть возможность того, что мы достигнем конца строки раньше, чем символа с номером <b><I>pos</i></b>. Эта возможность проверяется отдельно (блок 2) - не показывает ли <b><I>src</i></b> на символ с кодом 0 - признак конца строки. Следовательно, выход из цикла возможен либо по достижению нужного символа (блок 3), либо по достижению конца строки, причем, последнее возможно только при некорректном задании параметров. После выхода из цикла проверяется корректность задания параметров: не задана ли отрицательная длина подстроки (блок 6) и не выходит ли <b><I>pos</i></b> за пределы строки (блок 7). Отметим, что если значение <b><I>pos</i></b> ошибочно задано отрицательным, то цикл блокЁв 2 - 5 не выполнится ни одного раза и в блоке 7 значение <b><I>pos</i></b> будет ненулевым. Оно также будет ненулевым, если pos превышает длину строки-источника. В любом случае некорректного задания возвращаемое значение <b><I>ret</i></b> устанавливается в -1 (блок 8),  и управление переходит на завершение функции.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если же параметры заданы корректно, выполняется второй цикл (блоки 9 - 13). Этот цикл имеет параметром параметр функции <b><I>len</i></b>, который тоже " работает на уменьшение ". В каждой итерации символ, на который показывает указатель <b><I>src</i></b>, пересылается туда, куда показывает указатель <b><I>dest</i></b> (блок 11) после чего оба эти указателя увеличиваются на 1 (блок 12), а <b><I>len</i></b> уменьшается на 1. Когда значение <b><I>len</i></b> достигнет 0, это означает, что из источника в результат переслано уже <b><I>len</i></b> символов и происходит выход из цикла (блок 10). Другая возможность выхода - если будет найден конец строки прежде, чем закончится пересылка (блок 9). После выхода из цикла проверяется остаток в переменной <b><I>len</i></b> (блок 14). Если он нулевой, значение для <b><I>ret</i></b> устанавливается в 0 (блок 16), если нет - это означает, что переслано меньшее количество символов, и значение <b><I>ret</i></b> устанавливается в 1 (блок 17).
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Перед завершением в любом случае записывается признак конца строки туда, куда показывает <b><I>dest</i></b> (блок 17). Если функция завершается из-за некорректного задания параметров, это обеспечит пустую строку по адресу <b><I>dest</i></b>. То значение <b><I>ret</i></b>, которое было установлено при выполнении алгоритма, возвращается функцией (блок 18).

<h4 align=center>5.3. Функция <b><I>substr()</i></b>. Текст программы.</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Заголовок функции <b><I>substr()</i></b> полностью соответствует ее описанию, сформулированному при разработке спецификаций функции. В функции объявляется только одна локальная переменная - <b><I>ret</i></b> - в которой формируется то значение, которое возвращает функция.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Цикл, который на схеме алгоритма представлен блоками 2 - 5, реализован одним оператором:
<pre>
    for(; pos&amp;&amp;*src; pos--, src++);
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Начальные установки для цикла не нужны. Оба условия выхода из цикла проверяются одним выражением: 
<pre>
    pos&amp;&amp;*src, 
</pre>
что эквивалентно:   
<pre>
    (pos==0)&amp;&amp;(*src=0), 
</pre>
в конце каждой итерации уменьшается <b><I>pos</i></b> и увеличивается <b><I>src</i></b>. Тело этого цикла пустое.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Единственный условный оператор:
<pre>
    if (pos||(len&lt;0)) ret=-1;
</pre>
является программной реализацией проверок некорректного задания параметров (блоки 6 - 8).
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если параметры корректны, следующий оператор цикла выполняет пересылку символов из источника в результат (блоки 9 - 13):
<pre>
    for(;len&amp;&amp;*src; *dest++=*src++,len--);
</pre>
Этот цикл тоже имеет пустое тело, ибо все действия, которые нужно в нем выполнять заданы в заголовке цикла.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После цикла проверяется остаток и устанавливается значение <b><I>ret</i></b> (блоки 14 - 16):
<pre>
    ret = len ? 1 : 0;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Перед возвратом еще записывается признак конца строки (символ с кодом 0) в результат (блок 17):
<pre>
    *dest=0;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При завершении функция возвращает (блок 18) значение <b><I>ret</i></b>:
<pre>
    return ret;
</pre>

<h4 align=center>5.4. Функция main()</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Основным результатом нашего проекта должна быть функция <b><I>substr()</i></b>. Но эта функция не может выполняться самостоятельно, она должна вызываться из какой-нибудь внешней функции. Вообще для выполнения любого программного кода, написанного на языке C, в нем должна быть функция <b><I>main()</i></b>. На эту функцию мы возлагаем задачи ввода данных и вывода результатов. Следовательно, чтобы заставить нашу функцию <b><I>substr()</i></b> выполняться и проверить ее выполнение, мы должны создать также и функцию <b><I>main()</i></b>.

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>5.4.1. Переменные функции main()</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В функции main() должны быть объявлены переменные для:
<ul>
<li>строки-источника:
<pre>
        char s1[80];
</pre>
<li>строки-результата:
<pre>
        char s2[80];
</pre>
<li>позиции первого символа в подстроке:
<pre>
        int n;
</pre>
<li>длины подстроки:
<pre>
        int l;
</pre>
<li>того значения, которое вернет функция <b><I>substr()</i></b>:
<pre>
        int r;
</pre>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Пользуясь случаем, сделаем небольшое отступление, чтобы предупредить Вас про возможность ошибки, которую часто допускают начинающие программисты. Зная, что обращение к символьным строкам в языке C происходит через указатель на начало строки, такие программисты иногда объявляют символьную строку как <b><I>char *</i></b>. Но такое объявление, например:
<pre>
   char *s1;
</pre>
выделяет память только для размещения указателя, но не для размещения самих символов строки. Если далее мы введем, например, 80 символов функцией <b><I>gets(s1)</i></b>, то символы разместятся там, куда показывает указатель s1, но значение этого указателя не определено, следовательно, и символы разместятся неизвестно где. Следовательно, символьная строка обязательно должна быть объявлена как массив символов - этим выделяется для нее память, а уже обращаться к ней можно через указатель.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Не следует также забывать про необходимость резервировать в строке дополнительную позицию для признака конца строки.

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>5.4.2. Текст функции <b><I>main()</i></b></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После объявления переменных текст функции <b><I>main()</i></b> состоит из единственного бесконечного цикла. В каждой его итерации прежде всего выводится приглашение не ввод строки-источника. Следующий оператор, возможно, требует более детального рассмотрения:
<pre>
    if (!strcmp(gets(s1),"***")) break;
</pre>
При его выполнении прежде всего выполняется функция <b><I>gets(s1)</i></b>, которая вводит данные в строку s1. Эта функция возвращает указатель на строку s1. Строка, на которую показывает этот указатель, сравнивается с помощью функции <b><I>strcmp()</i></b> со строковой константой <b><I>"***"</i></b>. Если они равны, <b><I>strcmp()</i></b> возвращает 0, тогда значение логического выражения в условном операторе истинное и выполняется выход из бесконечного цикла. Следовательно, цикл будет выполняться, пока не будет введена строка <b><I>"***"</i></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Потом вводятся значения переменных <b><I>n</i></b> и <b><I>l</i></b> и выполняется вызов функции <b><I>substr()</i></b>, которой передаются параметры <b><I>s1</i></b>, <b><I>s2</i></b>, <b><I>n</i></b>, <b><I>l</i></b>. Значения, которое возвращает <b><I>substr()</i></b>, присваивается переменной <b><I>r</i></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Строка-источник, строка-результат и возвращенное значение выводятся на экран, и цикл повторяется. (Обратите внимание на то, что при выводе символьных строк мы берем их в "скобки": &gt;&gt; &lt;&lt;. Это сделано для того, чтобы на экране можно было разглядеть символы-пробелы, которые могут быть в начале и в конце строк.)
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Обращение к функции <b><I>gets()</i></b> в конце цикла - "технологическое". Дело в том, что функция <b><I>scanf()</i></b> оставляет в буфере ввода последний код клавиши <b><I>Enter</i></b>, которым был закончен ввод. Если не будет "технологического" <b><I>gets()</i></b>, то gets() в следующей итерации цикла прочитает этот символ, как пустую строку. Так что "технологическое" <b><I>gets()</i></b> удаляет из буфера код клавиши <b><I>Enter</i></b>. Чтобы убедиться, попробуйте его убрать и посмотрите, что получится.

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>5.4.3. Общие объявления</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В функции <b><I>main()</i></b> применяются библиотечные функции ввода-вывода и функция сравнения строк, так что включим в программу файлы <b><I>stdio.h</i></b> и <b><I>string.h</i></b>. Кроме того, следует включить и описание функции <b><I>substr()</i></b>. Хотя все эти описания нужны только для функции <b><I>main()</i></b>, стиль программирования на языке C требует размещения их в начале программы, вне программных блоков.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Полный текст программы приведен ниже.

<pre>
/****************************************************/
/*             Лабораторная работа ╧12              */
/*      Указатели, символьные строки и  функции     */
/*         Приклад выполнения. Вариант ╧30.         */
/****************************************************/
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int substr(char *, char *, int, int);
/*** главная функция ***/
int main(void) {
  char s1[80],s2[80]; /* источник и результат */
  int n, l, r; /* позиция, длина, результат */
  for (;;) {   /* бесконечный цикл */
     printf("Введите строку &gt;");
     /* ввод строки-источника */
     if (!strcmp(gets(s1),"***")) break;
     /* ввод остальных параметров */
     printf("Введиту pos len&gt;");
     scanf("%d %d",&amp;n,&amp;l);
     /* обращение к функции substr() */
     r=substr(s1,s2,n,l);
     /* вывод результатЁв */ 
     printf("pos=%d, len=%d\n",n,l);
     printf("s1=&gt;&gt;%s&lt;&lt;\n",s1);
     printf("s2=&gt;&gt;%s&lt;&lt;\n",s2);
     printf("R=%d\n\n",r);
     gets(s1);
     }
}
/*** функция выделения подстроки ***/
/* параметры: 
     src - строка-источник
     dest - строка-результат
     pos - позиция, с которой выделяется подстрока
     len - длина подстроки
   функция возвращает: 
     0 - нормальное выполнение
     1 - подстрока имеет меньшую длину, чем задано
    -1 - ошибка в параметрах, результат пустой */
int substr(char *src, char *dest, int pos, int len) {
 int ret; /* значение, которое возвращается */
  /* выход на начальную позицию */
  for(; pos&amp;&amp;*src; pos--, src++);
  /* проверка параметров */
  if (pos||(len&lt;0)) ret=-1;
  else {    /* параметры корректны */
    /* пересылка символов */
    for(;len&amp;&amp;*src; *dest++=*src++,len--);
    /* проверка длины результата */
    ret = len ? 1 : 0;
    }
  /* запись признака конца в результат */
  *dest=0;
  return ret;
}
</pre>

<h4 align=center>5.5. Отладка программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При отладке программы в пошаговом режиме следует отслеживать:
<ul>
<li>правильность передачи параметров функции,
<li>правильность выхода на начальный символ подстроки, 
<li>правильность контроля параметров,
<li>правильность копирования символов,
<li>правильность окончательного формирования строки-результата (достаточно распространенной ошибкой является отсутствие признака конца в строке-результате).
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следует отметить, что при наличии некоторых ошибок отладка может быть несколько неудобной за счет того, что в функции применены очень мощные операторы цикла, которые занимают одну строку. В пошаговом режиме все итерации такого цикла выполняются за один шаг. При наличии ошибок в цикле, возможно, нужно будет "разгружать" оператор цикла - переносить часть действий из заголовка цикла в его тело.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Очень важно подобрать для отладки такие входные данные, которые позволили бы убедиться в правильном функционировании программы на всех ветвях ее алгоритма. Мы при отладке этой работы использовали во всех случаях строку-источник вида: "0123456789". Такой вид позволяет легко установить по выводу на экран, какое преобразование было выполнено функцией. Параметры <b><I>pos</i></b> и <b><I>len</i></b> мы задавали в таких вариантах:
<p><table>
<tr><td><pre>pos=2, len=3</td><td>
- проверка правильности работы при правильных заданиях параметров </td></tr>
<tr><td><pre>pos=0,len=4</td><td>
- подстрока начинается с начала строки</td></tr>
<tr><td><pre>pos=6, len=4</td><td>
- подстрока заканчивается на конце строки</td></tr>
<tr><td><pre>pos=0, len=10</td><td>
- подстрока захватывает всю строку</td></tr>
<tr><td><pre>pos=3, len=0</td><td>
- подстрока нулевой длины</td></tr>
<tr><td><pre>pos=8, len=4</td><td>
- особый случай: подстрока будет иметь меньшую длину, чем задано </td></tr>
<tr><td><pre>pos=3, len=-2</td><td>
- ошибка: отрицательная длина</td></tr>
<tr><td><pre>pos=-1, len=3</td><td>
- ошибка: отрицательная начальная позиция</td></tr>
<tr><td><pre>pos=10, len=3</td><td>
- ошибка: позиция начала больше длины источника</td></tr>
</table>

<h4 align=center>5.6. Результаты работы программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Результаты работы программы при приведенных выше входных данных такие:
<pre>
pos=2, len=3
s2=&gt;&gt;0123456789&lt;&lt;
s1=&gt;&gt;234&lt;&lt;
R=0

pos=0, len=4
s2=&gt;&gt;0123456789&lt;&lt;
s1=&gt;&gt;0123&lt;&lt;
R=0

pos=6, len=4
s2=&gt;&gt;0123456789&lt;&lt;
s1=&gt;&gt;6789&lt;&lt;
R=0

pos=0, len=10
s2=&gt;&gt;0123456789&lt;&lt;
s1=&gt;&gt;0123456789&lt;&lt;
R=0

pos=3, len=0
s2=&gt;&gt;0123456789&lt;&lt;
s1=&gt;&gt;&lt;&lt;
R=0

pos=8, len=4
s2=&gt;&gt;0123456789&lt;&lt;
s1=&gt;&gt;89&lt;&lt;
R=1

pos=3, len=-2
s2=&gt;&gt;0123456789&lt;&lt;
s1=&gt;&gt;&lt;&lt;
R=-1

pos=-1, len=3
s2=&gt;&gt;0123456789&lt;&lt;
s1=&gt;&gt;&lt;&lt;
R=-1

pos=10, len=3
s2=&gt;&gt;0123456789&lt;&lt;
s1=&gt;&gt;&lt;&lt;
R=1
</pre>

<h4 align=center>5.7. Выводы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При выполнении лабораторной работы изучены вопросы:
<ul>
<li>работы с массивами и символьными строками через указатели.
</ul>

<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l11.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l13.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>
