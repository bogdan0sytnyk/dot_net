<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, C">

<title>Основы программирования. Лабораторные работы </title>
<!--                                                                   -->
<!-- (C) Owner: Alexander S. Derevjanko -->
<!-- (C) ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l10.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l12.html>Вперед</a></td></tr>
</table>
</p>
<hr>
<h2 align=center>Лабораторная работа ╧11</h2>

<h2 align=center>Указатели и массивы</h2>

<h3 align=center>1. Цель работы</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Целью лабораторной работы является получение практических навыков в работе с указателями и с адресной арифметикой в языке C.

<h3 align=center>2. Теми для предварительной проработки </h3>
<ul>
<li>Указатели. Типизированные указатели.
<li>Указатели и массивы.
<li>Адресная арифметика.
<li>Динамическое выделение памяти.
</ul>

<h3 align=center>3. Задания для выполнения </h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Выполнить задание лабораторной работы ╧8 с такими дополнительными условиями:
<ul>
<li>размер массива определяется в начале выполнения программы как случайное число в диапазоне 50 - 200;
<li>в тексте программы  запрещается применять операцию индексации.
</ul>

<h3 align=center>4. Варианты индивидуальных заданий</h3>

<p><table align=center>
<tr><td>&nbsp;<a href=v08_01.html>1</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_02.html>2</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_03.html>3</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_04.html>4</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_05.html>5</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_06.html>6</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_07.html>7</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_08.html>8</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v08_09.html>9</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_10.html>10</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v08_11.html>11</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_12.html>12</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_13.html>13</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_14.html>14</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_15.html>15</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_16.html>16</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_17.html>17</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_18.html>18</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_19.html>19</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_20.html>20</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v08_21.html>21</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_22.html>22</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_23.html>23</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_24.html>24</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_25.html>25</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_26.html>26</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_27.html>27</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_28.html>28</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_29.html>29</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v08_30.html>30</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table>
</p>

<h3 align=center>5. Пример решения задачи (вариант 30)</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Описание решения задачи приводится со ссылками на методические указания к работе <a href=l08.html>╧8</a>. Описываются только решения, отличные от тех, что принимались в работе ╧8.

<h4 align=center>5.1. Разработка алгоритма решения.</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Алгоритм решения задачи в основном - тот же, что и в работе ╧8, поэтому его схему ми тут не приводимо. Разница состоит в том, что в начале выполнения, после инициализации датчика случайных чисел, нужно получить случайное число в диапазоне 50 - 200 (назовем его <b><I>size</i></b>) и выделить память для массива целых чисел размером <b><I>size</i></b>. (На схеме алгоритма для работы ╧8 эти действия должны быть вставлены сразу же после блока 2). Перед самым выходом из программы мы должны освободить выделенную память (На схеме алгоритма для работы ╧8 - после блока 19).

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Существенные отличия возникают в реализации алгоритма. Проще всего задания могло бы быть выполнено простой заменой во всех местах операции индексации на операцию адресации, имея в виду тождественность:
<pre>
    Ar[i] <img src=l11_1.gif> *(Ar+i)
</pre>
Это соответствовало бы букве задания, но не духу языка C. Если мы переходим от индексации к адресации, у нас устраняется необходимость в индексах и даже в переменных, которые их представляют. Это приводит к другому способу реализации всех циклов. Если имя массива <b><I>Ar</i></b> является указателем на его начало, то вместо цикла, в котором индекс <b><I>i</i></b> меняется от <b><I>0</i></b> до <b><I>size</i></b>, мы можем организовать цикл, в котором некоторый текущий указатель <b><I>Cr</i></b> меняется от <b><I>Ar</i></b> до <b><I>Ar+size</i></b>. Также, когда нам нужно запомнить начало отрицательной последовательности, мы можем запоминать не индекс соответствующего элемента, а его адрес - указатель на него.

<h4 align=center>5.2. Определение переменных программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Переменные программы мы также описываем в сравнении с работой ╧8.
Память для массива целых чисел в нашей работе не выделяется на этапе компиляции, так что нам достаточно объявить в программе только переменную - указатель на начало массива:
<pre>
    int *Ar; 
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Размерность массива определяется при выполнении программы, так что для ее сохранения нужна отдельная переменная:
<pre>
    int size;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вместо переменных, которые в работе ╧8 являются индексами элементов массива, мы будем применять указатели: 
<pre>
    int *Cr; 
</pre>
это будет указатель на текущий элемент массива при его полном переборе, и:
<pre>
    int *Ir; 
</pre>
в этом указателе будет сохраняться адрес начала отрицательной последовательности, а потом - при обработке последовательности - адрес текущего ее элемента. 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Переменные для сохранения суммы элементов и среднего значения и количества элементов в последовательности остаются те же самые:
<pre>
    int av;     int nn; </pre>

<h4 align=center>5.3. Разработка текста программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Кроме тех файлов, которые были включены в текст программы работы ╧8: 
<pre>
    #include &lt;stdio.h&gt;
    #include &lt;time.h&gt;
    #include &lt;stdlib.h&gt;
</pre>
включаем также файл <b><I>alloc.h</i></b>, в котором содержатся описания функций динамического выделения/освобождения памяти:
<pre>
    #include &lt;alloc.h&gt;</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Начинаем главную функцию и объявляем в ней переменные программы по п.5.2.
Кодовая часть программы начинается с инициализации датчика случайных чисел и получения случайного числа для размера массива:
<pre>
    randomize();
    size=random(151)+50;</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Функция <b><I>rand</i></b> возвращает нам число в диапазоне 0 - 150, прибавлением к нему 50 мы переводим его в диапазон 50 - 200. Полученный размер массива сразу выводим на экран:
<pre>
    printf("size=%d\n",size);
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Обращаемся к функции выделения памяти:
<pre>
    Ar=(int far *)malloc(size*sizeof(int));
</pre>
Функция <b><I>malloc()</i></b> требует параметр - размер запрошенной памяти в байтах. Переменная <b><I>size</i></b> - это количество элементов в массиве; для задания размера памяти в байтах умножаем ее на размер одного элемента. Функция <b><I>malloc()</i></b>возвращает нетипизированный указатель, мы преобразуем его в указатель на <b><I>int</i></b> и записываем в переменную <b><I>Ar</i></b>.

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее организуем цикл перебора массива. В отличие от работы ╧8 мы тут в одном цикле и получаем случайные числа, и выводим начальный массив на экран. Заголовок этого цикла существенно отличается от работы ╧8:
<pre>
    for (Cr=Ar; Cr&lt;Ar+size; Cr++) {
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В начальных установках цикла мы записываем в переменную <b><I>Cr</i></b> адрес начала массива, т.е. <b><I>Cr</i></b> показывает на элемент с индексом 0. В конце каждой итерации <b><I>Cr</i></b> увеличивается на 1, т.е. показывает на следующий элемент массива. Последняя итерация происходит при значении <b><I>Cr=Ar+size-1</i></b>, т.е. <b><I>Cr</i></b> будет показывать на последний элемент. В каждой итерации мы обращаемся к текущему элементу массива как <b><I>*Cr</i></b>, т.е. обращаемся к тому, на что показывает указатель <b><I>Cr</i></b>. 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее идет заголовок цикла перебора массива, который организуется та же, как предыдущий, но в начальных установках мы еще присваиваемо начальное значение счетчику <b><I>nn</i></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Тело цикла в основном подобно тому, что есть в лабораторной работе ╧8 за исключением того, что к текущему элементу массива мы обращаемся через указатель на него: <b><I>*Cr</i></b>. Там, где нам требуется запомнить начало отрицательной последовательности, мы просто сохраняем текущее значение указателя <b><I>Cr</i></b> в переменной-указателе <b><I>Ir</i></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Внутренний цикл, в котором обрабатывается отрицательная последовательность, существенно отличается от работы ╧8:
<pre>
    for (av/=nn; Ir&lt;Cr; Ir++)
      if (*Ir&lt;av) *Ir=av;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Начальные установки этого цикла - только усреднение значения в <b><I>av</i></b>, переменная <b><I>Ir</i></b> уже содержит в себе указатель на первый элемент отрицательной последовательности. В конце каждой итерации <b><I>Ir</i></b> увеличивается на 1, т.е. показывает на следующий элемент последовательности (обращение к этому элементу - <b><I>*Ir</i></b>). Последняя итерация происходит при значении <b><I>Ir=Cr-1</i></b>, поскольку <b><I>Cr</i></b> показывает на первый положительный элемент за отрицательной последовательностью. 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Остаток программы повторяет предыдущие фрагменты.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Предпоследний оператор - обращение к функции <b><I>free()</i></b> для освобождения памяти, которая была выделена функцией <b><I>malloc()</i></b>:
    free(Ar);
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Полный текст программы приведен ниже.

<pre>
/****************************************************/
/*             Лабораторная работа ╧11              */
/*              Указатели и массивы                 */
/*          Пример выполнения. Вариант ╧30.         */
/****************************************************/
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;alloc.h&gt;
int main(void) {
 int size;                   /* размер массива */
 int *Ar;       /* указатель на начало массива */
 int *Cr, *Ir;            /* текущие указатели */
 int av, nn;            /* среднее значение и
    количество элементов в последовательности  */
  randomize();  /* инициализация rand */
  size=random(151)+50;
  printf("size=%d\n",size);
  /* выделения памяти */
  Ar=(int far *)malloc(size*sizeof(int));
  /* заполнение массива случайными числами и
     вывод начального массива */
  printf("Начальный массив:\n");
  for (Cr=Ar; Cr&lt;Ar+size; Cr++) {
    *Cr=random(101)-50;
    printf("%3d ",*Cr);
    }
  putchar('\n');

  /* перебор массива */
  for (nn=0, Cr=Ar; Cr&lt;Ar+size; Cr++) { 
    if (*Cr&lt;0)
      /* обработка отрицательного элемента */
      if (!nn) {
          /* начало последовательности: запомнить адрес 
             начала в Ir, установить начальное значение 
               накопителя суммы и счетчике элементов */
         Ir=Cr; av=*Cr; nn=1;
         }
      else {
      /* подсчет суммы и количества элементов */
        av+=*Cr; nn++;
        }
    /* конец обработки отрицательного элемента */
    else /* обработка положительного элемента */
      if (nn) {
          /* если есть необработанная отрицательная последовательность: 
             усреднение и перебор с ограничением */
        for (av/=nn; Ir&lt;Cr; Ir++)
          if (*Ir&lt;av) *Ir=av;
        nn=0; /* последовательность обработана */
        }  /* конец если есть необработанная... */
    }  /* конец перебора массива */
  if (nn) /* если не обработана последняя 
             отрицательная последовательность */
    for (av/=nn; Ir&lt;Cr; Ir++)
      if (*Ir&lt;av) *Ir=av;
  /* вывод результатов */
  printf("Массив-результат:\n");
  for (Cr=Ar; Cr&lt;Ar+size; printf("%3d ",*Cr++));
  putchar('\n');
  /* освобождение памяти */
  free(Ar);
  return 0;
}
</pre>

<h4 align=center>5.4. Отладка программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Отладку программы следует вести по тому же плану, что и в работе ╧8. Следует, однако, отметить, что отслеживать значения в пошаговом режиме тут несколько труднее, ибо если в работе ╧8 мы могли видеть достаточно понятные значения индексов, то тут вместо них мы увидим значения указателей, более сложные для понимания. Поэтому мы рекомендуем больше полагаться на выявление ошибок путем анализа результатов программы.

<h4 align=center>5.5. Результаты работы программы</h4>

Образец результатов программы приведен ниже

<pre>
size=69
Начальный массив:
-50   8  13 -16  11 -45  21 -12  -6 -45  17  21  41  36 -12 -42  24 -14  -9 -14  
 50 -31 -37 -49  48 -37  50 -20 -43  46 -30  33  21  24 -36  12 -20 -48 -27  -8  
 -6 -36 -21 -24 -31   8 -23  24 -33  13 -15  -6  -8 -43 -48  22 -49  49  19  12  
 18 -17  31  47  45  -2  28  42 -49 
Массив-результат:
-50   8  13 -16  11 -45  21 -12  -6 -21  17  21  41  36 -12 -27  24 -12  -9 -12
 50 -31 -37 -39  48 -37  50 -20 -31  46 -30  33  21  24 -36  12 -20 -24 -24  -8
 -6 -24 -21 -24 -24   8 -23  24 -33  13 -15  -6  -8 -24 -24  22 -49  49  19  12
 18 -17  31  47  45  -2  28  42 -49 
</pre>

<h4 align=center>5.6. Выводы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При выполнении лабораторной работы изучены вопросы:
<ul>
<li>работа с массивами через указатели;
<li>динамическое выделение и освобождение памяти.
</ul>
<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l10.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l12.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>
