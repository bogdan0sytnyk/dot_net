<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, C">

<title>Основы программирования. Лабораторные работы </title>
<!--                                                                   -->
<!-- (C) Owner: Alexander S. Derevjanko -->
<!-- (C) ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l05.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l07.html>Вперед</a></td></tr>
</table>
</p>
<hr>
<h2 align=center>Лабораторная работа ╧6</h2>

<h2 align=center>Операторы цикла в языке C</h2>

<h3 align=center>1. Цель работы</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Целью лабораторной работы является получение практических навыков в работе с операторами цикла языка C.

<h3 align=center>2. Темы для предварительной проработки </h3>
<ul><li>Операторы цикла языка C.</ul>

<h3 align=center>3. Задания для выполнения</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для ряда, члены которого вычисляются по формуле, соответствующей Вашему индивидуальному заданию, подсчитать сумму членов ряда с точностью до 0.000001 и сумму первых 10 членов ряда. Если Вы считаете это необходимым, можете упростить или преобразовать выражение.

<h3 align=center>4. Варианты индивидуальных заданий</h3>
<p><table align=center>
<tr><td>&nbsp;<a href=v06_01.html>1</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v06_02.html>2</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v06_03.html>3</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v06_04.html>4</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v06_05.html>5</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v06_06.html>6</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v06_07.html>7</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v06_08.html>8</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v06_09.html>9</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_10.html>10</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v06_11.html>11</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_12.html>12</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_13.html>13</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_14.html>14</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_15.html>15</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_16.html>16</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_17.html>17</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_18.html>18</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_19.html>19</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_20.html>20</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v06_21.html>21</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_22.html>22</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_23.html>23</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_24.html>24</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_25.html>25</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_26.html>26</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_27.html>27</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_28.html>28</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_29.html>29</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v06_30.html>30</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table>
</p>

<h3 align=center>5. Пример решения задачи (вариант 30)</h3>

<h4 align=center>5.1. Разработка алгоритма решения.</h4>

<p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.1. Общий метод решения</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Очевидно, что процесс подсчета суммы членов ряда должен быть итерационным: следует повторять вычисления по одной и  той же формуле при значениях <b><i>n=0, 1, 2, ...</i></b> . В каждой итерации цикла следует выполнять вычисления по заданной формуле для текущего значения <b><i>n</i></b>, т.е. подсчитывать очередной член ряда. Полученное значение следует прибавлять к переменной, которая представляет сумму. Эта переменная в каждой итерации будет содержать в себе сумму всех уже обработанных членов ряда, следовательно, ее начальное значение (когда ни один член еще не обработан) должно быть 0. После вычисления суммы при значении <b><i>n=9</i></b> следует вывести значение суммы - это один из результатов программы в соответствии с заданием (берется значение 9, т.к. первый член ряда вычисляется при <b><i>n=0</i></b>, таким образом, девятый - при <b><i>n=9</i></b>). После вычисления каждого члена ряда (но до прибавления его значения к сумме) следует сравнить полученное значение с заданным пределом точности. Из-за того, что значение члена ряда может быть как положительным, так и отрицательным, при сравнении следует использовать абсолютное значение. Если абсолютное значения  члена ряда не превышает предела точности, следует закончить вычисления: выйти из цикла напечатать значение суммы и завершить программу.

<p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.2. Алгоритм вычисления <b><i>2<sup>n</sup></i></b></b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для выполнения возведения в степень можно применить библиотечную функцию C <b><i>pow(x,y) </i></b>. Но есть возможность получения этого значения более эффективным способом. В каждой следующей итерации цикла значение  этого выражения вдвое больше, чем в предыдущей. Так что, будет целесообразно выделить отдельную переменную для сохранения значения <b><i>2<sup>n</sup></i></b>. Ее начальное значение должно быть <b><i>2<sup>0</sup> = 1</i></b>, а в конце каждой итерации оно должно удваиваться.

<p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.3. Алгоритм вычисления <b><i>(-1)<sup>n</sup></i></b></b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В этом случае также нецелесообразно применять функцию возведения в степень. Значение этого выражения будет 1 при четных значениях <b><i>n</i></b> и -1 - при нечетных. Так что, можно выделить переменную для сохранения значения этого выражения. Ее начальное значение должно быть <b><i>(-1)<sup>0</sup>=1</i></b>, а в конце каждой итерации оно должно менять знак на противоположный.

<p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.4. Схема алгоритма</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Мы построили начальный (не показанный здесь) вариант схемы алгоритма на базе соображений, высказанных в пп.5.1.1, а потом усовершенствовали его. Результирующий вариант схемы алгоритма показан на рисунке.

<p><table align=center border>
<tr><td><img src=l06_e31.gif></td></tr>
</table>
<h4 align=center>5.2. Определение переменных программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Все переменные нашей программы соответствуют переменным, которые введены в схеме алгоритма. Дополнительно определим их типы.

<p><b><i>n</i></b> - параметр ряда; по условиям задачи это - целое число; поскольку заранее неизвестно, сколько итераций цикла будет нужно для достижения предела точности, объявим его как "длинное целое":
<pre>
    long n;
</pre>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Отметим, что хотя по условию задания <b><i>n</i></b> - целое, результаты выражений, в которых фигурирует <b><i>n</i></b>, будут иметь дробную часть. Преобразование типов можно выполнять непосредственно при вычислении выражения, но чтобы заранее исключить ошибки, введем еще одну переменную - <b><i>dbln</i></b>, которая будет представлять значение <b><i>n</i></b> как числа с плавающей точкой:
<pre>
    double dbln;
</pre>
<p><b><i>term</i></b> - значение текущего члена ряда. Объявим его как:
<pre>
    double term;
</pre>
<p><b><i>sum</i></b> - текущее значение суммы ряда с начальным значением 0. Объявим его как:
<pre>
    double sum=0;
</pre>
<p><b><i>k2</i></b> - переменная для сохранения текущего значения <b><i>2<sup>n</sup></i></b> с начальным значением 1 (см. пп.5.1.2). Она должна быть "длинным целым" - из тех же соображений, что и <b><i>n</i></b>:
<pre>
    long k2=1;
</pre>
<p><b><i>k1</i></b> - переменная для сохранения текущего значения <b><i>(-1)<sup>n</sup></i></b> с начальным значением 1 (см. пп.5.1.3). Для нее достаточно быть "коротким целым":
<pre>
    short k1=1;
</pre>
<p><b><i>eps</i></b> - переменная для представления заданного предела точности. Она должна иметь начальное (неизменное) значение 0.000001, поэтому может быть объявлена как <b><i>const</i></b>. Использование переменной для представления константы вместо употребления константы непосредственно в операторах программы может повысить гибкость программы:
<pre>
    const double eps=0.000001;
</pre>

<h4 align=center>5.3. Разработка текста программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Начинаем разработку текста программы с заголовка главной функции <b><i>main()</i></b>:
<pre>
    int main(void)
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее открывается тело функции, и в него включаются определения переменных (см. п.5.2). Определения переменных реализуют блок 2 схемы алгоритма. В дополнение к переменным, определенным в схеме алгоритма, объявляем рабочую переменную <b><i>dbln</i></b> и константу <b><i>eps</i></b>. Поскольку правила языка C позволяют присваивать переменным начальные значения, в объявлении переменных отчасти реализован также и блок 3.
Блоки 4 - 9 схемы алгоритма образуют цикл. В языке С есть два "простых" оператора цикла: цикл с предусловием - <b><i>while</i></b> и цикл с постусловием - <b><i>do-while</i></b>. Но по схеме алгоритма видно, что выход из цикла происходит в середине тела цикла (блок 5): после вычисления члена ряда, но до добавления его значения к сумме. Следовательно, "простые" циклы применить нельзя. "Сложный" оператор цикла - <b><i>for</i></b> - является циклом с предусловием, но задавать условие в самом операторе цикла необязательно. К тому же  этот оператор дает возможность определить действия, которые нужно выполнить до начала цикла и действия, которые выполняются в конце каждой итерации. Таким образом, открытие цикла будет иметь вид:
<pre>
    for (n=0; ; n++, k2*=2, k1=-k1) {
</pre>
где первый параметр <b><i>for</i></b> - присваивание начального значения переменной <b><i>n</i></b> (остаток блока 3), второй параметр - условие выхода из цикла - пустой, третий параметр реализует блок 8 схемы алгоритма. В теле цикла содержится несколько отдельных действий, значит, будет несколько операторов, поэтому тело цикла берется в операторные скобки.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В теле цикла первый оператор: 
<pre>
    dbln=n;
</pre>
это действие не предусмотрено в схеме алгоритма, но его необходимость мы пояснили в п.5.2.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее вычисляется значение текущего члена ряда:
<pre>
    term=k1*(dbln+1)/(dbln*dbln+k2);
</pre>
этот оператор полностью реализует блок 4 и формулу из индивидуального задания (учитывая пп.5.1.2, 5.1.3) за исключением того, что вместо операции возведения в степень 2 мы применяем умножение.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следующее действие - проверка достижения предела точности - на схеме алгоритма представлена блоком 5 и выполняется условным оператором, который начинается с:
<pre>
    if (fabs(term)&gt;=eps) 
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следует отметить, что сравнивается абсолютное значение <b><i>term</i></b>, а функция для получения абсолютного значения переменной типа <b><i>double</i></b> - <b><i>fabs()</i></b>. Эта функция описана в файле <b><i>math.h</i></b>, так что мы должны включить этот файл в начало программы:
<pre>
    #include &lt;math.h&gt;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Продолжение условного оператора, действие, которое выполняется при выполнении условия, - добавление значения члена к сумме (блок 6):
<pre>
    sum+=term;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При невыполнении условия мы должны выйти из цикла, так что условный оператор требует и второй части:
<pre>
    else break;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По схеме алгоритма нам надо проверить, не достигла ли переменная <b><i>n</i></b> значения 9 (блок 7), и, если да, - печатать значение суммы (блок 8). Это реализуется условным оператором:
<pre>
    if (n==9)  printf("Сумма 10 членов ряда = %10.7lf\n",sum);
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Поскольку при невыполнении условия не делается ничего, часть <b><i>else</i></b> для этого оператора не нужна.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При вызове функции <b><i>printf()</i></b> всегда возникает проблема форматизации вывода. Мы включили в формат текст, который поясняет вывод, а значение переменной <b><i>sum</i></b> выводим по спецификации <b><i>%10.7lf</i></b>. Тип спецификации соответствует типу переменной - <b><i>double</i></b>, а числовые параметры мы выбрали произвольно, поскольку в задании не оговорены требования к точности вывода. Перед точкой мы оставляем 2 позиции - для знака и целой части (которая должна быть 0), после точки - 7 позиций, что на 1 превышает точность заданного предела точности.
Функция <b><i>printf()</i></b> описана в файле <b><i>stdio.h</i></b>, поэтому мы включаем этот файл в начало программы:
<pre>
    #include &lt;stdio.h&gt;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Поскольку блок 9 схемы алгоритма реализован нами в заголовке цикла, то цикл на этом заканчивается, и мы ставим операторную скобку, закрывающую тело цикла.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Выход из цикла происходит по оператору <b><i>break</i></b> в составе условного оператора. После выхода из цикла мы должны напечатать окончательное значение суммы (блок 10), что мы и делаем оператором:
<pre>
    printf("Полная сумма ряда = %10.7lf\n",sum);
</pre>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При определении формата вывода работают те же соображения, что и в предыдущем случае.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Реализация алгоритма закончена, мы ставим операторную скобку, которая закрывает тело функции <b><i>main()</i></b>.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Полный текст программы приведен ниже.

<pre>
/****************************************************/
/*              Лабораторная работа ╧6              */
/*               Вычисление суммы ряда              */
/*          Пример выполнения. Вариант ╧30.         */
/****************************************************/
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
int main(void) { long n;              /* параметр ряда */
 double dbln;         /* параметр ряда в форме с плавающей точкой */
 double sum=0;        /* сумма членов ряда */
 double term;         /* значение текущего члена */
 const double eps=0.000001;  /* предел точности */
 long k2=1;           /* pow(2,n)*/
 short k1=1;          /* pow(-1,n)*/
   /* основной цикл; в модификациях вычисляются 
      следующие значения pow(2,n) и pow(-1,n)*/
   for (n=0; ; n++, k2*=2, k1=-k1) {
     /* преобразование n в форму с плавающей точкой */
     dbln=n;
     /* вычисление очередного члена */                          term=k1*(dbln+1)/(dbln*dbln+k2);
     /* проверка достижения предела точности */       
     if (fabs(term)&gt;=eps) 
        /* если не достигнут - накопление суммы */ 
        sum+=term;     /* если достигнут - выход из цикла */ 
     else break;      /* если 10 членов - вывод суммы */               
     if (n==9)       
        printf("Сумма 10 членов ряда = %10.7lf\n",sum);     }
   /* конец основного цикла */
   /* вывод окончательной суммы */
   printf("Полная сумма ряда = %10.7lf\n",sum);      return 0;
} /* конец программы */
</pre>

<h4 align=center>5.4. Отладка программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При отладке программы целесообразно использовать пошаговый режим с отслеживанием значений переменных - прежде всего: <b><i>n</i></b>, <b><i>term</i></b>, <b><i>sum</i></b>. Следует выполнить шаг за шагом несколько итераций цикла, убеждаясь, что эти переменные получают правильные значения. В таком режиме нетрудно выполнить 10 итераций и убедиться в правильном формировании первого результата. Если возникают ошибки при вычислении наиболее сложного выражения в программе:
    term=k1*(dbln+1)/(dbln*dbln+k2);
можно включить в программу временные дополнительные переменные и разбить выражение на простые составляющие, проверяя на шаг за шагом значения этих переменных. Например:
<pre>
   double temp1, temp2; /* временные переменные */
   . . .
   temp1=dbln+1;
   temp2=dbln*dbln;
   temp2=temp2+k2;
   temp1=temp1/temp2;
   term=k1*temp1;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для того, чтобы убедиться в правильном выводе второго результата, имеет смысл при отладке выводить вместе с суммой и номер итерации, на котором закончилась робота цикла, и значение члена ряда, которое оказалось меньше предела точности:
<pre>
    printf("%ld %10.7lf\n",n,term); 
</pre>

<h4 align=center>5.5. Результаты работы программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При работе программы на экран были выведены такие результаты:
<pre>
Сумма 10 членов ряда = 0.5600899
Полная сумма ряда = 0.5663245
</pre>

<h4 align=center>5.6. Выводы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При выполнении лабораторной работы изучены вопросы:<ul>
<li>составления циклических алгоритмов;
<li>программной реализации циклических алгоритмов;
<li>отладки программ, содержащих циклические алгоритмы.
</ul>

<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l05.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l07.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>
