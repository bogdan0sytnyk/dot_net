<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, C">

<title>Основы программирования. Лабораторные работы </title>
<!--                                                                   -->
<!-- (C) Owner: Alexander S. Derevjanko -->
<!-- (C) ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l08.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l10.html>Вперед</a></td></tr>
</table>
</p>
<hr>
<h2 align=center>Лабораторная работа ╧9</h2>

<h2 align=center>Работа с матрицами</h2>

<h3 align=center>1. Цель работы</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Целью лабораторной работы является получение практических навыков в работе с матрицами в языке C.

<h3 align=center>2. Темы для предварительной проработки</h3>
<ul>
<li>Операторы цикла языка C. Вложенные циклы.
<li>Условный оператор языка C.
<li>Матрицы.
</ul>

<h3 align=center>3. Задания для выполнения</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Создать квадратную матрицу целых чисел размером 9х9. В индивидуальных заданиях указано, какую обработку матрицы требуется выполнить.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если по условию задания матрицу следует заполнить случайными числами, рекомендуем выбирать эти числа из диапазона 0 - 99. Если по условию задания в матрицу следует записать ЛП - линейную последовательность чисел, имеется в виду последовательность: 1, 2, 3, ...

<h3 align=center>4. Варианты индивидуальных заданий</h3>
<p><table align=center>
<tr><td>&nbsp;<a href=v09_01.html>1</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_02.html>2</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_03.html>3</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_04.html>4</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_05.html>5</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_06.html>6</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_07.html>7</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_08.html>8</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>&nbsp;<a href=v09_09.html>9</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_10.html>10</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v09_11.html>11</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_12.html>12</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_13.html>13</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_14.html>14</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_15.html>15</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_16.html>16</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_17.html>17</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_18.html>18</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_19.html>19</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_20.html>20</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td><a href=v09_21.html>21</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_22.html>22</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_23.html>23</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_24.html>24</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_25.html>25</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_26.html>26</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_27.html>27</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_28.html>28</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_29.html>29</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a href=v09_30.html>30</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table>
</p>

<h3 align=center>5. Пример решения задачи (вариант 30) </h3>

<h4 align=center>5.1. Разработка алгоритма решения.</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если ми обозначим размерность матрицы как <b><I>S</I></b>, номер строки как <b><I>L</I></b>, а номер столбца как <b><I>R</I></b>, и (имея в виду, что реализация алгоритма будет выполнена на языке С) договоримся, что нумерация строк и столбцов будет начинаться с 0, то можно определить, что в строке с номером <b><I>L</I></b> ненулевые элементы в верхней части матрицы лежат на столбцах с номерами <b><I>R1=L &lt; R &lt; R2=S-L</I></b>, а в нижней - <b><I>R1=S-L-1 &lt; R &lt; R2=L</I></b>. Следовательно, алгоритм может состоять из перебора матрицы строка за строкой с определением для каждого элемента, удовлетворяют ли его индексы вышеприведенным условиям. Если да - элементу присваивается следующее значение из ЛП, если нет - 0. 

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Но можно несколько упростить алгоритм, обойдя вычисления граничных значений для каждого элемента и необходимости определения, в верхнюю или нижнюю часть матрицы ми попадаем. Обратим внимание на то, что для первой строки <b><I>(L=0) R1=1, R2=S-2</I></b>. Для каждой следующей строки <b><I>R1</I></b> увеличивается на 1, а <b><I>R2</I></b> уменьшается на 1. Когда мы пересекаем середину матрицы, то направление модификации изменяется на противоположное: теперь для каждой следующей строки <b><I>R1</I></b> уменьшается на 1, а <b><I>R2</I></b> увеличивается на 1. Признаком пересечения середины может быть условие <b><I>R1 &gt; R2</I></b>, оно выполняется в момент пересечения. Схема последнего алгоритма показана на рисунке.

<p><table border align=center><tr><td><img src=l09_e031.gif></td></tr></table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вместе с описанными выше переменными <b><I>R1</I></b> и <b><I>R2</I></b>, которые получают начальные значения для первой строки матрицы, ми вводим переменную <b><I>dd</I></b> с начальным значением 1 - это то значение, которое будет модифицировать <b><I>R1</I></b> и <b><I>R2</I></b> для каждой следующей строки, и переменную <b><I>k</I></b> - в которой будет значение текущего члена ЛП, начальное значение - 1 (блок 2).
Далее организуются вложенные циклы. Во внешнем цикле перебираются строки (блок 3), а во внутреннем - столбцы матрицы (блок 4). В каждой итерации внутреннего цикла номер столбца <b><I>R</I></b> сравнивается с граничными значениями <b><I>R1</I></b>, <b><I>R2</I></b> (блоки 5,6). Если он лежит в пределах от <b><I>R1</I></b> до <b><I>R2</I></b>, то текущему члену матрицы присваивается значение <b><I>k</I></b> - текущего члена ЛП, а затем <b><I>k</I></b> увеличивается на 1 (блок 7). Если нет, текущему члену присваивается значение 0 (блок 8).
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После выхода из внутреннего цикла модифицируются граничные значения: <b><I>R1</I></b> увеличивается на <b><I>dd</I></b>, а <b><I>R2</I></b> уменьшается на <b><I>dd</I></b> (блок 9). Напомним, что начальное значение <b><I>dd=1</I></b>. Когда выполняется условие <b><I>R1 &gt; R2</I></b> (блок 10) мы присваиваем <b><I>dd</I></b> значение -1, далее модификация границ будет соответствовать правилам для нижней части матрицы.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После выхода из внешнего цикла, который начался в блоке 3, вновь организуются вложенные цикли перебора строк (блок 12) и столбцов (блок 13). В каждой итерации внутреннего цикла выводится значение одного элемента матрицы (блок 14), после выхода из внутреннего цикла начинается новая строка вывода (блок 15).

<h4 align=center>5.2. Определение переменных программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для реализации алгоритма нам будут нужны такие переменные.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Матрица представляется в памяти как 2-мерний массив (должен быть размещен в статической памяти):
<pre>
    int Ar[S][S];
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Переменные для представления текущих номеров строки (<b><I>l</I></b>) и столбца (<b><I>r</I></b>):
<pre>
    short l, r;  
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Переменные для представления граничных номеров столбцов:
<pre>
    short r1,r2;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Переменная - модификатор граничных номеров:
<pre>
    short dd;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Переменная - текущий член ЛП:
<pre>
    short k;
</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Всем скалярным переменным назначаем тип <b><I>short</I></b>, т.к. их значения никак не могут выходить из диапазона -128 - 128. 

<h4 align=center>5.3. Разработка текста программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Текст программы начинаемо с включения файла <b><I>stdio.h</I></b> и определения макроконстанты <b><I>S</I></b> - размера матрицы (хотя по условию задания можно было бы использовать просто константу 9 в тексте программы, определение размера через макроконстанту более соответствует стилю программирования на языке C).
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Массив-матрицу <b><I>Ar</I></b> объявляем до открытия тела главной функции, что обеспечивает его размещение в статической памяти.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Открываем тело главной функции и объявляем переменные в соответствии с п.5.2.
Присваиваем переменным <b><I>r1</I></b>, <b><I>r2</I></b>, <b><I>dd</I></b>, <b><I>k</I></b> начальные значения (это можно было сделать и при их объявлении).
Открываем цикл перебора строк с изменением <b><I>l</I></b> от <b><I>0</I></b> до <b><I>S-1</I></b> и цикл перебора столбцов с изменением <b><I>r</I></b> от <b><I>0</I></b> до <b><I>S-1</I></b>. Внутренний цикл состоит из одного условного оператора, так что нет необходимости брать его тело в операторные скобки. Тело внешнего цикла берется в скобки.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В условном операторе проверяем сразу оба условия (блоки 5 и 6). Поскольку для выхода за пределы должно выполняться хотя бы одно из них, они соединены операцией "ИЛИ".
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При выполнении условия значение <b><I>k</I></b> записывается в элемент массив с индексами <b><I>[l,r] </I></b> и сразу же увеличивается. При невыполнении - в элемент массива записывается 0.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После выхода из внутреннего цикла, но еще в теле внешнего модифицируются значения <b><I>r1</I></b> и <b><I>r2</I></b>. Потом условным оператором проверяется условие <b><I>r1&gt;r2</I></b> и, если он выполняется знак модификатора <b><I>dd</I></b> меняется на противоположный.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Потом открываются два цикла для вывода. В каждой итерации внутреннего цикла выводится значение одного элемента массива. Формат вывода обеспечивает вывод положительного числа из 2 цифр и пробела перед ним. После каждого выхода из внутреннего цикла выводится символ перехода на новую строку. Таким образом, матрица будет выведена в наглядном представлении.
Полный текст программы приведен ниже.
<pre>
/*****************************************************/
/*              Лабораторная работа ╧9               */
/*                 Работа с матрицами                */
/*           Пример выполнения. Вариант ╧30.         */
/*****************************************************/
#include &lt;stdio.h&gt;#define S 9int Ar[S][S]; /* матрица */
int main(void) {
 short l, r;  /* текущие индексы */
 short r1,r2; /* граничные номера столбцов */
 short dd;    /* модификатор граничных номеров */
 short k;     /* текущий член ЛП */
  /* начальные значения переменных */
  r1=1; r2=S-2; dd=1; k=1;  for (l=0; l&lt;S; l++) {  /* перебор строк */    for (r=0; r&lt;S; r++)  /* перебор столбцов */
      /* условие ненулевого значения */
      if ((r&lt;r1)||(r&gt;r2)) Ar[l][r]=0;
      else Ar[l][r]=k++;
      /* конец перебора строк */
    /* модификация границ */    r1+=dd; r2-=dd;
    /* уловие перехода в нижнюю часть */    if (r1&gt;r2) dd=-dd;    } /* конец перебора столбцов */
  /* вывод матрицы */  for (l=0; l&lt;S; l++) {    for (r=0; r&lt;S; r++) {      printf("%3d",Ar[l][r]);      }    printf("\n");    }  return 0;}
</pre>

<h4 align=center>5.4. Отладка программы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Форма вывода результатов программы столь наглядна, что по результатам можно убедиться в правильном функционировании программы или - при неправильном функционировании - можно делать выводы о том, у реализации какой именно ветви алгоритма сделана ошибка. При наличии ошибок можно в отладке программы также использовать средства пошаговой отладки, при чем следует контролировать текущие индексы граничные номера и текущее значение модификатора. Наиболее вероятные ошибки - неправильное определение граничных номеров или неправильное определение момента перехода в нижнюю часть матрицы.


<h4 align=center>5.5. Результаты работы программы</h4>

Результат работы программы приведен ниже:
<pre>
  0  1  2  3  4  5  6  7  0
  0  0  8  9 10 11 12  0  0
  0  0  0 13 14 15  0  0  0
  0  0  0  0 16  0  0  0  0
  0  0  0  0  0  0  0  0  0
  0  0  0  0 17  0  0  0  0
  0  0  0 18 19 20  0  0  0
  0  0 21 22 23 24 25  0  0
  0 26 27 28 29 30 31 32  0
</pre>

<h4 align=center>5.6. Выводы</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При выполнении лабораторной работы изучены вопросы:
<ul>
<li>работы с матрицами;
<li>написания и отладки циклических программ, включая вложенные циклы.
</ul>

<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=l08.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=l10.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>
